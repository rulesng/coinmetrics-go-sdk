// Package Openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package v4

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	Api_keyScopes = "api_key.Scopes"
)

// Defines values for OrderBookType.
const (
	OrderBookTypeSnapshot OrderBookType = "snapshot"

	OrderBookTypeUpdate OrderBookType = "update"
)

// Defines values for Backfill.
const (
	Latest Backfill = "latest"

	None Backfill = "none"
)

// Defines values for ExchangeAssetSort.
const (
	ExchangeAsset ExchangeAssetSort = "exchange_asset"

	// Time ExchangeAssetSort = "time"
)

// Defines values for ExchangeSort.
const (
	Exchange ExchangeSort = "exchange"

	// Time ExchangeSort = "time"
)

// Defines values for Format.
const (
	Csv Format = "csv"

	Json Format = "json"
)

// Defines values for InstitutionSort.
const (
	// Institution InstitutionSort = "institution"

	// Time InstitutionSort = "time"
)

// Defines values for MarketMetricsSort.
const (
	// Market MarketMetricsSort = "market"

	// Time MarketMetricsSort = "time"
)

// Defines values for PagingFrom.
const (
	End PagingFrom = "end"

	Start PagingFrom = "start"
)

// Defines values for PairSort.
const (
	// Pair PairSort = "pair"

	// Time PairSort = "time"
)

// Defines values for Sort.
const (
	Asset Sort = "asset"

	Height Sort = "height"

	// Time Sort = "time"
)

// Defines values for Status.
const (
	All Status = "all"

	Flash Status = "flash"

	Reviewed Status = "reviewed"

	Revised Status = "revised"
)

// Name of the asset.
// type Asset string

// AssetAlert defines model for AssetAlert.
type AssetAlert struct {
	// Asset alert name.
	Alert AssetAlertName `json:"alert"`

	// Name of the asset.
	Asset string `json:"asset"`

	// Becomes 'active' if there was a breach of the Key Risk Indicator, otherwise stays 'inactive'.
	Status AssetAlertStatus `json:"status"`

	// Asset alert's Key Risk Indicator threshold value. Omitted if the corresponding alert rule consists of multiple conditions.
	Threshold *AssetAlertThreshold `json:"threshold,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// Captured value of the alerting metric. Omitted if the ratio-based alert's divisor constituent was equal to zero or if the corresponding alert rule consists of multiple conditions.
	Value *AssetAlertValue `json:"value,omitempty"`
}

// Asset alert name.
type AssetAlertName string

// Information about the asset alert.
type AssetAlertRuleInfo struct {
	// Unique name of the asset.
	Asset AssetId `json:"asset"`

	// Conditions that should be met in order for the corresponding asset alert to be produced.
	Conditions AssetAlertSubRules `json:"conditions"`

	// Name of the asset alert.
	Name AssetAlertRuleName `json:"name"`
}

// Name of the asset alert.
type AssetAlertRuleName string

// AssetAlertRulesResponse defines model for AssetAlertRulesResponse.
type AssetAlertRulesResponse struct {
	Data []AssetAlertRuleInfo `json:"data"`
}

// Becomes 'active' if there was a breach of the Key Risk Indicator, otherwise stays 'inactive'.
type AssetAlertStatus string

// Information about the asset alert condition.
type AssetAlertSubRule struct {
	// Names of the alerting metrics that form an alerting value to be compared against the Key Risk Indicator threshold.
	Constituents AssetAlertSubRuleConstituents `json:"constituents"`

	// Description of the asset alert.
	Description AssetAlertSubRuleDescription `json:"description"`

	// Asset alert's Key Risk Indicator triggering value. Omitted if asset alert condition depends on the variable metric threshold (this fact will be reflected in the condition description).
	Threshold *AssetAlertSubRuleThreshold `json:"threshold,omitempty"`
}

// Name of the alerting metric.
type AssetAlertSubRuleConstituent string

// Names of the alerting metrics that form an alerting value to be compared against the Key Risk Indicator threshold.
type AssetAlertSubRuleConstituents []AssetAlertSubRuleConstituent

// Description of the asset alert.
type AssetAlertSubRuleDescription string

// Asset alert's Key Risk Indicator triggering value. Omitted if asset alert condition depends on the variable metric threshold (this fact will be reflected in the condition description).
type AssetAlertSubRuleThreshold string

// Conditions that should be met in order for the corresponding asset alert to be produced.
type AssetAlertSubRules []AssetAlertSubRule

// Asset alert's Key Risk Indicator threshold value. Omitted if the corresponding alert rule consists of multiple conditions.
type AssetAlertThreshold string

// Captured value of the alerting metric. Omitted if the ratio-based alert's divisor constituent was equal to zero or if the corresponding alert rule consists of multiple conditions.
type AssetAlertValue string

// AssetAlerts defines model for AssetAlerts.
type AssetAlerts []AssetAlert

// Asset alerts response.
type AssetAlertsResponse struct {
	Data AssetAlerts `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Contains the chain fragments starting from the block which is a common ancestor for other blocks. If there is a single active chain - only the chain tip is included.<br/>
type AssetChain []AssetChainBlock

// AssetChainBlock defines model for AssetChainBlock.
type AssetChainBlock struct {
	// Hash of the block.
	Hash BlockchainBlockHash `json:"hash"`

	// Height of the block.
	Height BlockchainBlockHeight `json:"height"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// Information about the asset chains.
type AssetChains struct {
	// Name of the asset.
	Asset string `json:"asset"`

	// Count of the blocks on the maximum chain height.
	BlocksCountAtTip BlocksCountAtTip `json:"blocks_count_at_tip"`

	// All the chains that were active in the blockchain during the time that's enough to produce the amount of blocks considered as an industry standard number of confirmations.
	Chains []AssetChain `json:"chains"`

	// Count of all the chains that were active in the blockchain during the past hour.
	ChainsCount ChainsCount `json:"chains_count"`

	// Indicates if the last appended block triggered the chain reorganization.
	Reorg *Reorg `json:"reorg,omitempty"`

	// A number of consecutive blocks that were disconnected from the common ancestor block of the previous and current longest active chains during the chain reorganization.
	ReorgDepth *ReorgDepth `json:"reorg_depth,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// AssetChainsResponse defines model for AssetChainsResponse.
type AssetChainsResponse struct {
	Data []AssetChains `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Unique name of the asset.
type AssetId string

// Unique name of the base asset.
type AssetIdBase string

// Unique name of the quote asset.
type AssetIdQuote string

// Information about asset.
type AssetInfo struct {
	// Unique name of the asset.
	Asset AssetId `json:"asset"`

	// List of exchange names.
	Exchanges *ExchangesIds `json:"exchanges,omitempty"`

	// If set to true, discrepancies might be present in the dataset for this asset, and that's expected.
	Experimental *ExperimentalAsset `json:"experimental,omitempty"`

	// Human-friendly name.
	FullName FullName `json:"full_name"`

	// List of market names.
	Markets *MarketsIds `json:"markets,omitempty"`

	// List of metrics.
	Metrics *MetricsIds `json:"metrics,omitempty"`
}

// List of metric frequencies.
type AssetMetricFrequencies []AssetMetricFrequency

// AssetMetricFrequency defines model for AssetMetricFrequency.
type AssetMetricFrequency struct {
	// Indicates an availability of the metric in the community version of the API.
	Community *Community `json:"community,omitempty"`

	// Frequency of the metric.
	Frequency string `json:"frequency"`

	// Maximal available block hash for time series.
	MaxHash *MaxHash `json:"max_hash,omitempty"`

	// Maximal available block height for time series.
	MaxHeight *MaxHeight `json:"max_height,omitempty"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available black hash for time series.
	MinHash *MinHash `json:"min_hash,omitempty"`

	// Minimal available block height for time series.
	MinHeight *MinHeight `json:"min_height,omitempty"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about availabiliy of metric for an asset.
type AssetMetricInfo struct {
	// List of metric frequencies.
	Frequencies AssetMetricFrequencies `json:"frequencies"`

	// Name of the metric.
	Metric MetricId `json:"metric"`
}

// Time series of asset metrics.
type AssetMetricsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// List of asset names.
type AssetsIds []AssetId

// AssetsResponse defines model for AssetsResponse.
type AssetsResponse struct {
	Data []AssetInfo `json:"data"`
}

// The count of unique hashes at the chain tip.
type BlockHashesAtTip string

// Account id.
type BlockchainAccount string

// Balance of the account.
type BlockchainAccountBalance string

// Account type. The possible values are: `UTXO`, `VIRTUAL`, `ACCOUNT`.
type BlockchainAccountType string

// Blockchain accounts response.
type BlockchainAccountsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Blockchain accounts response.
type BlockchainAccountsResponseV2 struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Balance change.
type BlockchainBalanceChange string

// BlockchainBalanceUpdate defines model for BlockchainBalanceUpdate.
type BlockchainBalanceUpdate struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainTransactionBalanceUpdate)
	BlockchainTransactionBalanceUpdate `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Hash of the block.
	BlockHash BlockchainBlockHash `json:"block_hash"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	ConsensusTime Time `json:"consensus_time"`

	// Height of the block.
	Height BlockchainBlockHeight `json:"height"`

	// Hash of the transaction.
	TransactionHash *BlockchainTransactionHash `json:"transaction_hash,omitempty"`
}

// Boolean indicating whether the update is a credit or a debit of the account.
type BlockchainBalanceUpdateCredit bool

// BlockchainBalanceUpdateSubAccount defines model for BlockchainBalanceUpdateSubAccount.
type BlockchainBalanceUpdateSubAccount struct {
	// Height of the block.
	CreationHeight *BlockchainBlockHeight `json:"creation_height,omitempty"`

	// Number of credits.
	NCredits *BlockchainNumberOfCredits `json:"n_credits,omitempty"`

	// Number of debits.
	NDebits *BlockchainNumberOfDebits `json:"n_debits,omitempty"`

	// Balance of the account.
	NewBalance *BlockchainAccountBalance `json:"new_balance,omitempty"`

	// Balance of the account.
	PreviousBalance *BlockchainAccountBalance `json:"previous_balance,omitempty"`

	// It is used to order balance updates inside a single transaction to distinguish between serial and parallel balance updates.
	PreviousChainSequenceNumber *BlockchainTransactionSequenceNumber `json:"previous_chain_sequence_number,omitempty"`

	// Height of the block.
	PreviousCreditHeight *BlockchainBlockHeight `json:"previous_credit_height,omitempty"`

	// Height of the block.
	PreviousDebitHeight *BlockchainBlockHeight `json:"previous_debit_height,omitempty"`

	// Sub-account id.
	SubAccount *BlockchainSubAccount `json:"sub_account,omitempty"`

	// Total amount received.
	TotalReceived *BlockchainTotalReceived `json:"total_received,omitempty"`

	// Total amount sent.
	TotalSent *BlockchainTotalSent `json:"total_sent,omitempty"`
}

// BlockchainBalanceUpdateV2 defines model for BlockchainBalanceUpdateV2.
type BlockchainBalanceUpdateV2 struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainTransactionBalanceUpdateV2)
	BlockchainTransactionBalanceUpdateV2 `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Hash of the block.
	BlockHash BlockchainBlockHash `json:"block_hash"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	ConsensusTime Time `json:"consensus_time"`

	// Boolean indicating whether the update is a credit or a debit of the account.
	Credit BlockchainBalanceUpdateCredit `json:"credit"`

	// Height of the block.
	Height BlockchainBlockHeight `json:"height"`

	// Total amount received.
	TotalReceived BlockchainTotalReceived `json:"total_received"`

	// Total amount sent.
	TotalSent BlockchainTotalSent `json:"total_sent"`

	// Identifier (txid) of the transaction.
	Txid *BlockchainTransactionId `json:"txid,omitempty"`
}

// BlockchainBalanceUpdates defines model for BlockchainBalanceUpdates.
type BlockchainBalanceUpdates []BlockchainBalanceUpdate

// Blockchain transactions response.
type BlockchainBalanceUpdatesResponse struct {
	Data BlockchainBalanceUpdates `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Blockchain transactions response.
type BlockchainBalanceUpdatesResponseV2 struct {
	Data BlockchainBalanceUpdatesV2 `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// BlockchainBalanceUpdatesV2 defines model for BlockchainBalanceUpdatesV2.
type BlockchainBalanceUpdatesV2 []BlockchainBalanceUpdateV2

// Consensus size of the block.
type BlockchainBlockConsensusSize string

// Consensus size limit of the block.
type BlockchainBlockConsensusSizeLimit string

// Difficulty of the block.
type BlockchainBlockDifficulty string

// Extra data of the block, hex-encoded.
type BlockchainBlockExtraData string

// Hash of the block.
type BlockchainBlockHash string

// Height of the block.
type BlockchainBlockHeight string

// BlockchainBlockInfo defines model for BlockchainBlockInfo.
type BlockchainBlockInfo struct {
	// Hash of the block.
	BlockHash BlockchainBlockHash `json:"block_hash"`

	// Consensus size of the block.
	ConsensusSize *BlockchainBlockConsensusSize `json:"consensus_size,omitempty"`

	// Consensus size limit of the block.
	ConsensusSizeLimit *BlockchainBlockConsensusSizeLimit `json:"consensus_size_limit,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	ConsensusTime Time `json:"consensus_time"`

	// Difficulty of the block.
	Difficulty *BlockchainBlockDifficulty `json:"difficulty,omitempty"`

	// Height of the block.
	Height BlockchainBlockHeight `json:"height"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	MinerTime Time `json:"miner_time"`

	// Number of balance updates.
	NBalanceUpdates BlockchainNumberOfBalanceUpdates `json:"n_balance_updates"`

	// Number of transactions.
	NTransactions BlockchainNumberOfTransactions `json:"n_transactions"`

	// Hash of the block.
	ParentBlockHash *BlockchainBlockHash `json:"parent_block_hash,omitempty"`

	// Physical size of the block, bytes.
	PhysicalSize *BlockchainBlockPhysicalSize `json:"physical_size,omitempty"`
}

// BlockchainBlockInfoV2 defines model for BlockchainBlockInfoV2.
type BlockchainBlockInfoV2 struct {
	// Hash of the block.
	BlockHash BlockchainBlockHash `json:"block_hash"`

	// Consensus size of the block.
	ConsensusSize *BlockchainBlockConsensusSize `json:"consensus_size,omitempty"`

	// Consensus size limit of the block.
	ConsensusSizeLimit *BlockchainBlockConsensusSizeLimit `json:"consensus_size_limit,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	ConsensusTime Time `json:"consensus_time"`

	// Difficulty of the block.
	Difficulty *BlockchainBlockDifficulty `json:"difficulty,omitempty"`

	// Extra data of the block, hex-encoded.
	ExtraData *BlockchainBlockExtraData `json:"extra_data,omitempty"`

	// Height of the block.
	Height BlockchainBlockHeight `json:"height"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	MinerTime Time `json:"miner_time"`

	// Number of balance updates.
	NBalanceUpdates BlockchainNumberOfBalanceUpdates `json:"n_balance_updates"`

	// Number of transactions.
	NTransactions BlockchainNumberOfTransactions `json:"n_transactions"`

	// Nonce of the block, hex-encoded.
	Nonce *BlockchainBlockNonce `json:"nonce,omitempty"`

	// Hash of the block.
	ParentBlockHash *BlockchainBlockHash `json:"parent_block_hash,omitempty"`

	// Physical size of the block, bytes.
	PhysicalSize *BlockchainBlockPhysicalSize `json:"physical_size,omitempty"`

	// This field is set to true if the corresponding block is stale. Otherwise omitted.
	Stale *BlockchainStaleBlock `json:"stale,omitempty"`

	// Version of the block.
	Version *BlockchainBlockVersion `json:"version,omitempty"`
}

// Nonce of the block, hex-encoded.
type BlockchainBlockNonce string

// Physical size of the block, bytes.
type BlockchainBlockPhysicalSize string

// BlockchainBlockTransactionInfo defines model for BlockchainBlockTransactionInfo.
type BlockchainBlockTransactionInfo struct {
	// Sum of all debits in the transaction.
	Amount BlockchainTransactionAmount `json:"amount"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	ConsensusTime Time `json:"consensus_time"`

	// Chain sequence number.
	MaxChainSequenceNumber BlockchainChainSequenceNumber `json:"max_chain_sequence_number"`

	// Chain sequence number.
	MinChainSequenceNumber BlockchainChainSequenceNumber `json:"min_chain_sequence_number"`

	// Number of balance updates.
	NBalanceUpdates BlockchainNumberOfBalanceUpdates `json:"n_balance_updates"`

	// This field is set to true if the corresponding block is stale. Otherwise omitted.
	Stale *BlockchainStaleBlock `json:"stale,omitempty"`

	// Hash of the transaction.
	TransactionHash BlockchainTransactionHash `json:"transaction_hash"`
}

// BlockchainBlockTransactionInfoV2 defines model for BlockchainBlockTransactionInfoV2.
type BlockchainBlockTransactionInfoV2 struct {
	// Sum of all debits in the transaction.
	Amount BlockchainTransactionAmount `json:"amount"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	ConsensusTime Time `json:"consensus_time"`

	// Chain sequence number.
	MaxChainSequenceNumber BlockchainChainSequenceNumber `json:"max_chain_sequence_number"`

	// Chain sequence number.
	MinChainSequenceNumber BlockchainChainSequenceNumber `json:"min_chain_sequence_number"`

	// Number of balance updates.
	NBalanceUpdates BlockchainNumberOfBalanceUpdates `json:"n_balance_updates"`

	// This field is set to true if the corresponding block is stale. Otherwise omitted.
	Stale *BlockchainStaleBlock `json:"stale,omitempty"`

	// Identifier (txid) of the transaction.
	Txid BlockchainTransactionId `json:"txid"`
}

// Version of the block.
type BlockchainBlockVersion string

// Blockchain blocks response.
type BlockchainBlocksResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Blockchain blocks response.
type BlockchainBlocksResponseV2 struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Chain sequence number.
type BlockchainChainSequenceNumber string

// BlockchainFullBlockResponse defines model for BlockchainFullBlockResponse.
type BlockchainFullBlockResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainBlockInfo)
	BlockchainBlockInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	BalanceUpdates *BlockchainTransactionBalanceUpdates `json:"balance_updates,omitempty"`
	Transactions   *BlockchainFullTransactions          `json:"transactions,omitempty"`
}

// BlockchainFullBlockResponseV2 defines model for BlockchainFullBlockResponseV2.
type BlockchainFullBlockResponseV2 struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainBlockInfoV2)
	BlockchainBlockInfoV2 `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	BalanceUpdates *BlockchainTransactionBalanceUpdatesV2 `json:"balance_updates,omitempty"`
	Transactions   *BlockchainFullTransactionsV2          `json:"transactions,omitempty"`
}

// BlockchainFullSingleTransactionResponse defines model for BlockchainFullSingleTransactionResponse.
type BlockchainFullSingleTransactionResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainTransactionInfo)
	BlockchainTransactionInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	BalanceUpdates *BlockchainTransactionBalanceUpdates `json:"balance_updates,omitempty"`
}

// BlockchainFullSingleTransactionResponseV2 defines model for BlockchainFullSingleTransactionResponseV2.
type BlockchainFullSingleTransactionResponseV2 struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainTransactionInfoV2)
	BlockchainTransactionInfoV2 `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	BalanceUpdates *BlockchainTransactionBalanceUpdatesV2 `json:"balance_updates,omitempty"`
}

// BlockchainFullTransactionResponse defines model for BlockchainFullTransactionResponse.
type BlockchainFullTransactionResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainBlockTransactionInfo)
	BlockchainBlockTransactionInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	BalanceUpdates *BlockchainTransactionBalanceUpdates `json:"balance_updates,omitempty"`
}

// BlockchainFullTransactionResponseV2 defines model for BlockchainFullTransactionResponseV2.
type BlockchainFullTransactionResponseV2 struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainBlockTransactionInfoV2)
	BlockchainBlockTransactionInfoV2 `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	BalanceUpdates *BlockchainTransactionBalanceUpdatesV2 `json:"balance_updates,omitempty"`
}

// BlockchainFullTransactions defines model for BlockchainFullTransactions.
type BlockchainFullTransactions []BlockchainFullTransactionResponse

// BlockchainFullTransactionsV2 defines model for BlockchainFullTransactionsV2.
type BlockchainFullTransactionsV2 []BlockchainFullTransactionResponseV2

// Aggregate function result over the feerate values of all the mempool transactions.
type BlockchainMempoolFeerate string

// Transaction tracker response.
type BlockchainNodeLocationSeenTime struct {
	// A physical location of the blockchain node that have captured the transaction entering the mempool.
	Location NodeLocation `json:"location"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	SeenTime Time `json:"seen_time"`
}

// BlockchainNodeLocationSeenTimes defines model for BlockchainNodeLocationSeenTimes.
type BlockchainNodeLocationSeenTimes []BlockchainNodeLocationSeenTime

// Number of balance updates.
type BlockchainNumberOfBalanceUpdates string

// Number of credits.
type BlockchainNumberOfCredits string

// Number of debits.
type BlockchainNumberOfDebits string

// Number of transactions.
type BlockchainNumberOfTransactions string

// This field is set to true if the corresponding block is stale. Otherwise omitted.
type BlockchainStaleBlock string

// Sub-account id.
type BlockchainSubAccount string

// Sub-account latest balance.
type BlockchainSubAccountBalance string

// Blockchain sub-accounts response.
type BlockchainSubAccountsResponseV2 struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Total amount received.
type BlockchainTotalReceived string

// Total amount sent.
type BlockchainTotalSent string

// Sum of all debits in the transaction.
type BlockchainTransactionAmount string

// BlockchainTransactionBalanceUpdate defines model for BlockchainTransactionBalanceUpdate.
type BlockchainTransactionBalanceUpdate struct {
	// Account id.
	Account BlockchainAccount `json:"account"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	AccountCreationHeight Time `json:"account_creation_height"`

	// Chain sequence number.
	ChainSequenceNumber BlockchainChainSequenceNumber `json:"chain_sequence_number"`

	// Balance change.
	Change BlockchainBalanceChange `json:"change"`

	// Balance of the account.
	NewBalance BlockchainAccountBalance `json:"new_balance"`

	// Balance of the account.
	PreviousBalance BlockchainAccountBalance `json:"previous_balance"`

	// It is used to order balance updates inside a single transaction to distinguish between serial and parallel balance updates.
	PreviousChainSequenceNumber *BlockchainTransactionSequenceNumber `json:"previous_chain_sequence_number,omitempty"`

	// Height of the block.
	PreviousCreditHeight *BlockchainBlockHeight `json:"previous_credit_height,omitempty"`

	// Height of the block.
	PreviousDebitHeight *BlockchainBlockHeight `json:"previous_debit_height,omitempty"`

	// Number of credits.
	PreviousNCredits BlockchainNumberOfCredits `json:"previous_n_credits"`

	// Number of debits.
	PreviousNDebits BlockchainNumberOfDebits `json:"previous_n_debits"`

	// It is used to order balance updates inside a single transaction to distinguish between serial and parallel balance updates.
	TransactionSequenceNumber BlockchainTransactionSequenceNumber `json:"transaction_sequence_number"`
}

// BlockchainTransactionBalanceUpdateV2 defines model for BlockchainTransactionBalanceUpdateV2.
type BlockchainTransactionBalanceUpdateV2 struct {
	// Account id.
	Account BlockchainAccount `json:"account"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	AccountCreationHeight Time `json:"account_creation_height"`

	// Chain sequence number.
	ChainSequenceNumber BlockchainChainSequenceNumber `json:"chain_sequence_number"`

	// Balance change.
	Change BlockchainBalanceChange `json:"change"`

	// Number of credits.
	NCredits BlockchainNumberOfCredits `json:"n_credits"`

	// Number of debits.
	NDebits BlockchainNumberOfDebits `json:"n_debits"`

	// Balance of the account.
	NewBalance BlockchainAccountBalance `json:"new_balance"`

	// Balance of the account.
	PreviousBalance BlockchainAccountBalance `json:"previous_balance"`

	// It is used to order balance updates inside a single transaction to distinguish between serial and parallel balance updates.
	PreviousChainSequenceNumber *BlockchainTransactionSequenceNumber `json:"previous_chain_sequence_number,omitempty"`

	// Height of the block.
	PreviousCreditHeight *BlockchainBlockHeight `json:"previous_credit_height,omitempty"`

	// Height of the block.
	PreviousDebitHeight *BlockchainBlockHeight `json:"previous_debit_height,omitempty"`

	// This field is set to true if the corresponding block is stale. Otherwise omitted.
	Stale      *BlockchainStaleBlock              `json:"stale,omitempty"`
	SubAccount *BlockchainBalanceUpdateSubAccount `json:"sub_account,omitempty"`

	// It is used to order balance updates inside a single transaction to distinguish between serial and parallel balance updates.
	TransactionSequenceNumber BlockchainTransactionSequenceNumber `json:"transaction_sequence_number"`
}

// BlockchainTransactionBalanceUpdates defines model for BlockchainTransactionBalanceUpdates.
type BlockchainTransactionBalanceUpdates []BlockchainTransactionBalanceUpdate

// BlockchainTransactionBalanceUpdatesV2 defines model for BlockchainTransactionBalanceUpdatesV2.
type BlockchainTransactionBalanceUpdatesV2 []BlockchainTransactionBalanceUpdateV2

// Consensus size of the transaction.
type BlockchainTransactionConsensusSize string

// Fee of the transaction.
type BlockchainTransactionFee string

// Feerate of the transaction.
type BlockchainTransactionFeerate string

// Hash of the transaction.
type BlockchainTransactionHash string

// Identifier (txid) of the transaction.
type BlockchainTransactionId string

// BlockchainTransactionInfo defines model for BlockchainTransactionInfo.
type BlockchainTransactionInfo struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainBlockTransactionInfo)
	BlockchainBlockTransactionInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Hash of the block.
	BlockHash BlockchainBlockHash `json:"block_hash"`

	// Height of the block.
	Height BlockchainBlockHeight `json:"height"`
}

// BlockchainTransactionInfoV2 defines model for BlockchainTransactionInfoV2.
type BlockchainTransactionInfoV2 struct {
	// Embedded struct due to allOf(#/components/schemas/BlockchainBlockTransactionInfoV2)
	BlockchainBlockTransactionInfoV2 `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Hash of the block.
	BlockHash BlockchainBlockHash `json:"block_hash"`

	// Consensus size of the transaction.
	ConsensusSize *BlockchainTransactionConsensusSize `json:"consensus_size,omitempty"`

	// Fee of the transaction.
	Fee *BlockchainTransactionFee `json:"fee,omitempty"`

	// Height of the block.
	Height BlockchainBlockHeight `json:"height"`

	// Physical size of the transaction, bytes.
	PhysicalSize *BlockchainTransactionPhysicalSize `json:"physical_size,omitempty"`

	// This field is set to true if the corresponding block is stale. Otherwise omitted.
	Stale *BlockchainStaleBlock `json:"stale,omitempty"`

	// Version of the transaction.
	Version *BlockchainTransactionVersion `json:"version,omitempty"`
}

// Physical size of the transaction, bytes.
type BlockchainTransactionPhysicalSize string

// It is used to order balance updates inside a single transaction to distinguish between serial and parallel balance updates.
type BlockchainTransactionSequenceNumber string

// Version of the transaction.
type BlockchainTransactionVersion string

// Blockchain transactions response.
type BlockchainTransactionsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Blockchain transactions response.
type BlockchainTransactionsResponseV2 struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Count of the blocks on the maximum chain height.
type BlocksCountAtTip string

// BookEntry defines model for BookEntry.
type BookEntry struct {
	// The limit price of the order on the order book.
	Price *OrderBookPrice `json:"price,omitempty"`

	// The size of the limit order on the order book in units of the base asset.
	Size *OrderBookSize `json:"size,omitempty"`
}

// The closing price of the candle.
type CandlePriceClose string

// The high price of the candle.
type CandlePriceHigh string

// The low price of the candle.
type CandlePriceLow string

// The opening price of the candle.
type CandlePriceOpen string

// The number of trades used for candle calculation.
type CandleTradesCount string

// The volume of the candle in USD.
type CandleUsdVolume string

// The volume of the candle in units of the base asset.
type CandleVolume string

// The volume-weighted average price of the candle.
type CandleVwap string

// Frequencies of the candle.
type CatalogCandleFrequencies []CatalogCandleFrequency

// CatalogCandleFrequency defines model for CatalogCandleFrequency.
type CatalogCandleFrequency struct {
	// Frequency of the candle.
	Frequency string `json:"frequency"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// CatalogIndexFrequency defines model for CatalogIndexFrequency.
type CatalogIndexFrequency struct {
	// Frequency of the index.
	Frequency string `json:"frequency"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about market and its supported candle durations.
type CatalogMarketCandlesInfo struct {
	// Frequencies of the candle.
	Frequencies *CatalogCandleFrequencies `json:"frequencies,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`
}

// List of market candles statistics.
type CatalogMarketCandlesResponse struct {
	Data []CatalogMarketCandlesInfo `json:"data"`
}

// Information about market and its supported metrics.
type CatalogMarketMetricsInfo struct {
	// Unique name of the market.
	Market MarketId `json:"market"`

	// List of metrics.
	Metrics MarketMetricsIds `json:"metrics"`
}

// List of market metrics statistics.
type CatalogMarketMetricsResponse struct {
	Data []CatalogMarketMetricsInfo `json:"data"`
}

// Category of the metric.
type Category string

// Count of all the chains that were active in the blockchain during the past hour.
type ChainsCount string

// Unique identifier of object.
type CoinMetricsId string

// Indicates an availability of the metric in the community version of the API.
type Community bool

// Number of contracts.
type ContractCount string

// Contract value in USD.
type ContractValueUSD string

// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
type DatabaseTime string

// DeFi base address.
type DefiBaseAddress string

// DeFi contract address.
type DefiContractAddress string

// DeFi fee (in percents).
type DefiFee string

// DeFi pooling config ID.
type DefiPoolConfigId string

// DeFi quote address.
type DefiQuoteAddress string

// Human-friendly description.
type Description string

// More detailed and human friendly name of a metric.
type DisplayName string

// ErrorObject defines model for ErrorObject.
type ErrorObject struct {
	// Human-friendly error description. Can be amended without prior notification. Do not use for error identification in your code.
	Message *string `json:"message,omitempty"`

	// Error type string. Can be used for error identification.
	Type string `json:"type"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error ErrorObject `json:"error"`
}

// Name of the exchange.
// type Exchange string

// Unique combination of the exchange and asset.
// type ExchangeAsset string

// Information about Exchange Asset combination.
type ExchangeAssetInfo struct {
	// Unique combination of the exchange and asset.
	ExchangeAsset *string `json:"exchange_asset,omitempty"`

	// List of metrics.
	Metrics *ExchangeAssetMetricsIds `json:"metrics,omitempty"`
}

// List of metric frequencies.
type ExchangeAssetMetricFrequencies []ExchangeAssetMetricFrequency

// ExchangeAssetMetricFrequency defines model for ExchangeAssetMetricFrequency.
type ExchangeAssetMetricFrequency struct {
	// Frequency of the metric.
	Frequency string `json:"frequency"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about availabiliy of metric for an exchange asset.
type ExchangeAssetMetricInfo struct {
	// List of metric frequencies.
	Frequencies ExchangeAssetMetricFrequencies `json:"frequencies"`

	// Name of the metric.
	Metric MetricId `json:"metric"`
}

// List of metrics.
type ExchangeAssetMetricsIds []ExchangeAssetMetricInfo

// Time series of exchange metrics.
type ExchangeAssetMetricsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// ExchangeAssetsResponse defines model for ExchangeAssetsResponse.
type ExchangeAssetsResponse struct {
	Data []ExchangeAssetInfo `json:"data"`
}

// Unique name of the exchange.
type ExchangeId string

// Information about an exchange.
type ExchangeInfo struct {
	// Unique name of the exchange.
	Exchange ExchangeId `json:"exchange"`

	// List of market names.
	Markets MarketsIds `json:"markets"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// List of metrics.
	Metrics *ExchangeMetricsIds `json:"metrics,omitempty"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// List of metric frequencies.
type ExchangeMetricFrequencies []ExchangeMetricFrequency

// ExchangeMetricFrequency defines model for ExchangeMetricFrequency.
type ExchangeMetricFrequency struct {
	// Frequency of the metric.
	Frequency string `json:"frequency"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about availabiliy of metric for an exchange.
type ExchangeMetricInfo struct {
	// List of metric frequencies.
	Frequencies ExchangeMetricFrequencies `json:"frequencies"`

	// Name of the metric.
	Metric MetricId `json:"metric"`
}

// List of metrics.
type ExchangeMetricsIds []ExchangeMetricInfo

// Time series of Exchange metrics.
type ExchangeMetricsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// List of exchange names.
type ExchangesIds []ExchangeId

// ExchangesResponse defines model for ExchangesResponse.
type ExchangesResponse struct {
	Data []ExchangeInfo `json:"data"`
}

// If set to true, discrepancies might be present in the dataset for this asset, and that's expected.
type ExperimentalAsset bool

// If set to true, indicates that market collection is under active development - there is a chance of temporary discrepancies in the served dataset.
type ExperimentalMarket bool

// If set to true, indicates that metrics collection is under active development - there is a chance of temporary discrepancies in the served dataset.
type ExperimentalMetric bool

// Human-friendly name.
type FullName string

// Interval of a funding rate for a given market.
type FundingRateInterval string

// Period of a funding rate for a given market.
type FundingRatePeriod string

// Rate of a funding rate.
type FundingRateRate string

// Futures contract size.
type FutureContractSize string

// Futures expiration date.
type FutureExpiration string

// Futures listing date.
type FutureListing string

// Name of the futures margin asset.
type FutureMarginAsset string

// Name of the futures size asset.
type FutureSizeAsset string

// Futures tick size.
type FutureTickSize string

// The first derivative of the option's price to the underlying asset's price.
type GreeksDelta string

// The second derivative of the option's price to the underlying asset's price.
type GreeksGamma string

// The first derivative of the option's price to the risk free interest rate.
type GreeksRho string

// The first derivative of the option's price to the passage of time.
type GreeksTheta string

// The first derivative of the option's price to the volatility of the underlying asset's price.
type GreeksVega string

// Implied volatility calculated from ask price.
type ImpliedVolatilityAsk string

// Implied volatility calculated from bid price.
type ImpliedVolatilityBid string

// Implied volatility calculated from mark price.
type ImpliedVolatilityMark string

// Implied volatility calculated from last trade price.
type ImpliedVolatilityTrade string

// Name of the index.
type Index string

// Information about index constituents.
type IndexConstituents struct {
	Constituents []struct {
		// Unique name of the asset.
		Asset *AssetId `json:"asset,omitempty"`

		// The weight of the constituent.
		Weight *IndexWeight `json:"weight,omitempty"`
	} `json:"constituents"`

	// Name of the index.
	Index Index `json:"index"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// IndexConstituentsResponse defines model for IndexConstituentsResponse.
type IndexConstituentsResponse struct {
	Data []IndexConstituents `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Frequencies of the index.
type IndexFrequencies []CatalogIndexFrequency

// Name of the index.
type IndexId string

// Information about an index.
type IndexInfo struct {
	// Human-friendly description.
	Description Description `json:"description"`

	// Frequencies of the index.
	Frequencies IndexFrequencies `json:"frequencies"`

	// Human-friendly description.
	FullName Description `json:"full_name"`

	// Name of the index.
	Index IndexId `json:"index"`
}

// Information about index level.
type IndexLevel struct {
	// Name of the index.
	Index Index `json:"index"`

	// The value of the index.
	Level IndexLevelValue `json:"level"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// The value of the index.
type IndexLevelValue string

// IndexLevelsResponse defines model for IndexLevelsResponse.
type IndexLevelsResponse struct {
	Data []IndexLevel `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// The price index is an aggregate price derived from the major exchanges to be representative of the underlying asset's market consensus price.
type IndexPrice string

// The weight of the constituent.
type IndexWeight string

// IndexesResponse defines model for IndexesResponse.
type IndexesResponse struct {
	Data []IndexInfo `json:"data"`
}

// Institution name.
type Institution string

// Unique name of the institution.
type InstitutionId string

// Information about Instition.
type InstitutionInfo struct {
	// Unique name of the institution.
	Institution InstitutionId `json:"institution"`

	// List of metrics.
	Metrics *InstitutionMetricsIds `json:"metrics,omitempty"`
}

// List of metric frequencies.
type InstitutionMetricFrequencies []InstitutionMetricFrequency

// InstitutionMetricFrequency defines model for InstitutionMetricFrequency.
type InstitutionMetricFrequency struct {
	// Frequency of the metric.
	Frequency string `json:"frequency"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about availabiliy of metric for an institution.
type InstitutionMetricInfo struct {
	// List of metric frequencies.
	Frequencies InstitutionMetricFrequencies `json:"frequencies"`

	// Name of the metric.
	Metric MetricId `json:"metric"`
}

// List of metrics.
type InstitutionMetricsIds []InstitutionMetricInfo

// Time series of institution metrics.
type InstitutionMetricsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// InstitutionsResponse defines model for InstitutionsResponse.
type InstitutionsResponse struct {
	Data []InstitutionInfo `json:"data"`
}

// shows if the options contract is european or not.
type IsEuropean bool

// The amount of the base asset liquidated.
type LiquidationAmount string

// The price of the base asset quoted in the quote asset that the liquidation was executed at.
type LiquidationPrice string

// The market order side. "buy" means that an ask was removed from the book by an incoming buy order, "sell" means that a bid was removed from the book by an incoming sell order.
type LiquidationSide string

// The liquidation type. "trade" means that liquidation was executed, "order" means that the order was placed for the liquidation at the timestamp of the data entry but it wasn't necessarily executed yet.
type LiquidationType string

// ID of a liquidation (unique per exchange market). We are using exchange reported value if exchange reports a unique numeric liquidation id. If exchange reports liquidation id as a string we convert to numeric using Bijective mapping from exchange reported liquidation id's string. If exchange doesn't report unique ID we transform it using exchange reported data to form a unique value per market.
type LiquidationsCoinMetricsId string

// The price representing the futures' or option's price calculated by the exchange for risk management purposes.
type MarkPrice string

// Unique name of the market.
type Market string

// Information about market candle.
type MarketCandle struct {
	// The number of trades used for candle calculation.
	CandleTradesCount CandleTradesCount `json:"candle_trades_count"`

	// The volume of the candle in USD.
	CandleUsdVolume CandleUsdVolume `json:"candle_usd_volume"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The closing price of the candle.
	PriceClose CandlePriceClose `json:"price_close"`

	// The high price of the candle.
	PriceHigh CandlePriceHigh `json:"price_high"`

	// The low price of the candle.
	PriceLow CandlePriceLow `json:"price_low"`

	// The opening price of the candle.
	PriceOpen CandlePriceOpen `json:"price_open"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// The volume of the candle in units of the base asset.
	Volume CandleVolume `json:"volume"`

	// The volume-weighted average price of the candle.
	Vwap CandleVwap `json:"vwap"`
}

// MarketCandlesResponse defines model for MarketCandlesResponse.
type MarketCandlesResponse struct {
	Data []MarketCandle `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Information about market contract prices.
type MarketContractPrices struct {
	// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
	DatabaseTime DatabaseTime `json:"database_time"`

	// Time corresponding to option ticker data point, according to the exchange. Can be NULL, if exchange doesn't support it.
	ExchangeTime *OptionTickerExchangeTime `json:"exchange_time,omitempty"`

	// The price index is an aggregate price derived from the major exchanges to be representative of the underlying asset's market consensus price.
	IndexPrice *IndexPrice `json:"index_price,omitempty"`

	// The price representing the futures' or option's price calculated by the exchange for risk management purposes.
	MarkPrice *MarkPrice `json:"mark_price,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// MarketContractPricesResponse defines model for MarketContractPricesResponse.
type MarketContractPricesResponse struct {
	Data []MarketContractPrices `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Information about funding rate.
type MarketFundingRate struct {
	// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
	DatabaseTime DatabaseTime `json:"database_time"`

	// Interval of a funding rate for a given market.
	Interval *FundingRateInterval `json:"interval,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// Period of a funding rate for a given market.
	Period *FundingRatePeriod `json:"period,omitempty"`

	// Rate of a funding rate.
	Rate *FundingRateRate `json:"rate,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// Time series of market funding rates.
type MarketFundingRatesDataArray []MarketFundingRate

// MarketFundingRatesResponse defines model for MarketFundingRatesResponse.
type MarketFundingRatesResponse struct {
	// Time series of market funding rates.
	Data MarketFundingRatesDataArray `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Information about market greeks.
type MarketGreeks struct {
	// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
	DatabaseTime DatabaseTime `json:"database_time"`

	// The first derivative of the option's price to the underlying asset's price.
	Delta *GreeksDelta `json:"delta,omitempty"`

	// Time corresponding to option ticker data point, according to the exchange. Can be NULL, if exchange doesn't support it.
	ExchangeTime *OptionTickerExchangeTime `json:"exchange_time,omitempty"`

	// The second derivative of the option's price to the underlying asset's price.
	Gamma *GreeksGamma `json:"gamma,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The first derivative of the option's price to the risk free interest rate.
	Rho *GreeksRho `json:"rho,omitempty"`

	// The first derivative of the option's price to the passage of time.
	Theta *GreeksTheta `json:"theta,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// The first derivative of the option's price to the volatility of the underlying asset's price.
	Vega *GreeksVega `json:"vega,omitempty"`
}

// MarketGreeksResponse defines model for MarketGreeksResponse.
type MarketGreeksResponse struct {
	Data []MarketGreeks `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Unique name of the market.
type MarketId string

// Information about market implied volatility.
type MarketImpliedVolatility struct {
	// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
	DatabaseTime DatabaseTime `json:"database_time"`

	// Time corresponding to option ticker data point, according to the exchange. Can be NULL, if exchange doesn't support it.
	ExchangeTime *OptionTickerExchangeTime `json:"exchange_time,omitempty"`

	// Implied volatility calculated from ask price.
	IvAsk *ImpliedVolatilityAsk `json:"iv_ask,omitempty"`

	// Implied volatility calculated from bid price.
	IvBid *ImpliedVolatilityBid `json:"iv_bid,omitempty"`

	// Implied volatility calculated from mark price.
	IvMark *ImpliedVolatilityMark `json:"iv_mark,omitempty"`

	// Implied volatility calculated from last trade price.
	IvTrade *ImpliedVolatilityTrade `json:"iv_trade,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// MarketImpliedVolatilityResponse defines model for MarketImpliedVolatilityResponse.
type MarketImpliedVolatilityResponse struct {
	Data []MarketImpliedVolatility `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Information about a market.
type MarketInfo struct {
	// Unique name of the base asset.
	Base *AssetIdBase `json:"base,omitempty"`

	// DeFi base address.
	BaseAddress *DefiBaseAddress `json:"base_address,omitempty"`

	// DeFi contract address.
	ContractAddress *DefiContractAddress `json:"contract_address,omitempty"`

	// Futures contract size.
	ContractSize *FutureContractSize `json:"contract_size,omitempty"`

	// Name of the exchange.
	Exchange string `json:"exchange"`

	// If set to true, indicates that market collection is under active development - there is a chance of temporary discrepancies in the served dataset.
	Experimental *ExperimentalMarket `json:"experimental,omitempty"`

	// Futures expiration date.
	Expiration *FutureExpiration `json:"expiration,omitempty"`

	// DeFi fee (in percents).
	Fee *DefiFee `json:"fee,omitempty"`

	// Available time range for time series.
	FundingRates *MarketTimeRange `json:"funding_rates,omitempty"`

	// shows if the options contract is european or not.
	IsEuropean *IsEuropean `json:"is_european,omitempty"`

	// Available time range for time series.
	Liquidations *MarketTimeRange `json:"liquidations,omitempty"`

	// Futures listing date.
	Listing *FutureListing `json:"listing,omitempty"`

	// Name of the futures margin asset.
	MarginAsset *FutureMarginAsset `json:"margin_asset,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`

	// Available time range for time series.
	Openinterest *MarketTimeRange `json:"openinterest,omitempty"`

	// 'call or 'put' option contract type.
	OptionContractType *OptionContractType `json:"option_contract_type,omitempty"`

	// Available time range for time series.
	Orderbooks *MarketTimeRange `json:"orderbooks,omitempty"`

	// DeFi pooling config ID.
	PoolConfigId *DefiPoolConfigId `json:"pool_config_id,omitempty"`

	// Unique name of the quote asset.
	Quote *AssetIdQuote `json:"quote,omitempty"`

	// DeFi quote address.
	QuoteAddress *DefiQuoteAddress `json:"quote_address,omitempty"`

	// Available time range for time series.
	Quotes *MarketTimeRange `json:"quotes,omitempty"`

	// Name of the futures size asset.
	SizeAsset *FutureSizeAsset `json:"size_asset,omitempty"`

	// Strike price for option trade.
	Strike *OptionStrike `json:"strike,omitempty"`

	// Unique name of the derivative market symbol.
	Symbol *MarketSymbol `json:"symbol,omitempty"`

	// Futures tick size.
	TickSize *FutureTickSize `json:"tick_size,omitempty"`

	// Available time range for time series.
	Trades *MarketTimeRange `json:"trades,omitempty"`

	// Type of the market (spot, future).
	Type MarketType `json:"type"`
}

// Information about liquidation.
type MarketLiquidation struct {
	// The amount of the base asset liquidated.
	Amount LiquidationAmount `json:"amount"`

	// ID of a liquidation (unique per exchange market). We are using exchange reported value if exchange reports a unique numeric liquidation id. If exchange reports liquidation id as a string we convert to numeric using Bijective mapping from exchange reported liquidation id's string. If exchange doesn't report unique ID we transform it using exchange reported data to form a unique value per market.
	CoinMetricsId LiquidationsCoinMetricsId `json:"coin_metrics_id"`

	// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
	DatabaseTime DatabaseTime `json:"database_time"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The price of the base asset quoted in the quote asset that the liquidation was executed at.
	Price LiquidationPrice `json:"price"`

	// The market order side. "buy" means that an ask was removed from the book by an incoming buy order, "sell" means that a bid was removed from the book by an incoming sell order.
	Side *LiquidationSide `json:"side,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// The liquidation type. "trade" means that liquidation was executed, "order" means that the order was placed for the liquidation at the timestamp of the data entry but it wasn't necessarily executed yet.
	Type LiquidationType `json:"type"`
}

// Time series of market liquidations.
type MarketLiquidationsDataArray []MarketLiquidation

// MarketLiquidationsResponse defines model for MarketLiquidationsResponse.
type MarketLiquidationsResponse struct {
	// Time series of market liquidations.
	Data MarketLiquidationsDataArray `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// List of metric frequencies.
type MarketMetricFrequencies []MarketMetricFrequency

// MarketMetricFrequency defines model for MarketMetricFrequency.
type MarketMetricFrequency struct {
	// Frequency of the metric.
	Frequency string `json:"frequency"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about availabiliy of metric for a market.
type MarketMetricInfo struct {
	// List of metric frequencies.
	Frequencies MarketMetricFrequencies `json:"frequencies"`

	// Name of the metric.
	Metric MetricId `json:"metric"`
}

// List of metrics.
type MarketMetricsIds []MarketMetricInfo

// Time series of market metrics.
type MarketMetricsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Information about open interest.
type MarketOpenInterest struct {
	// Number of contracts.
	ContractCount ContractCount `json:"contract_count"`

	// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
	DatabaseTime DatabaseTime `json:"database_time"`

	// Time corresponding to open interest data point, according to the exchange. Can be NULL, if exchange doesn't support it.
	ExchangeTime *OpenInterestExchangeTime `json:"exchange_time,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// Contract value in USD.
	ValueUsd ContractValueUSD `json:"value_usd"`
}

// Time series of market open interest.
type MarketOpenInterestDataArray []MarketOpenInterest

// MarketOpenInterestResponse defines model for MarketOpenInterestResponse.
type MarketOpenInterestResponse struct {
	// Time series of market open interest.
	Data MarketOpenInterestDataArray `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Information about order book.
type MarketOrderBook struct {
	// The ask orders on the order book.
	Asks OrderBookAsks `json:"asks"`

	// The bids orders on the order book.
	Bids OrderBookBids `json:"bids"`

	// Unique identifier of object.
	CoinMetricsId CoinMetricsId `json:"coin_metrics_id"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// MarketOrderbookResponse defines model for MarketOrderbookResponse.
type MarketOrderbookResponse struct {
	Data []MarketOrderBook `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Information about market quote.
type MarketQuote struct {
	// The limit price of the top ask on the order book. If no asks in the order book, an entry is skipped.
	AskPrice QuoteAskPrice `json:"ask_price"`

	// The size of the top ask on the order book. If no asks in the order book, an entry is skipped.
	AskSize QuoteAskSize `json:"ask_size"`

	// The limit price of the top bid on the order book. If no bids in the order book, an entry is skipped.
	BidPrice QuoteBidPrice `json:"bid_price"`

	// The size of the top bid on the order book. If no bids in the order book, an entry is skipped.
	BidSize QuoteBidSize `json:"bid_size"`

	// Unique identifier of object.
	CoinMetricsId CoinMetricsId `json:"coin_metrics_id"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// MarketQuotesResponse defines model for MarketQuotesResponse.
type MarketQuotesResponse struct {
	Data []MarketQuote `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Unique name of the derivative market symbol.
type MarketSymbol string

// Available time range for time series.
type MarketTimeRange struct {
	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about trade.
type MarketTrade struct {
	// The amount of the base asset traded.
	Amount TradeAmount `json:"amount"`

	// Swap output receiver. Available for DeFi markets only.
	Beneficiary *TradeBeneficiary `json:"beneficiary,omitempty"`

	// Swap block hash. Available for DeFi markets only.
	BlockHash *TradeBlockHash `json:"block_hash,omitempty"`

	// Swap block height. Available for DeFi markets only.
	BlockHeight *TradeBlockHeight `json:"block_height,omitempty"`

	// ID of a trade (unique per exchange market). We are using exchange reported value if exchange reports a unique numeric trade id. If exchange reports trade id as a string we convert to numeric using Bijective mapping from exchange reported trade id's string. If exchange doesn't report unique ID we transform it using exchange reported data to form a unique value per market.
	CoinMetricsId TradesCoinMetricsId `json:"coin_metrics_id"`

	// A time when we saved the data in the database. The time is in ISO 8601 date-time format. Always with nanoseconds precision.
	DatabaseTime DatabaseTime `json:"database_time"`

	// Swap transaction initiator. Available for DeFi markets only.
	Initiator *TradeInitiator `json:"initiator,omitempty"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The price of the base asset quoted in the quote asset that the trade was executed at.
	Price TradePrice `json:"price"`

	// Swap caller. Available for DeFi markets only.
	Sender *TradeSender `json:"sender,omitempty"`

	// The market order side. "buy" means that an ask was removed from the book by an incoming buy order, "sell" means that a bid was removed from the book by an incoming sell order.
	Side *TradeSide `json:"side,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// Swap transaction ID. Available for DeFi markets only.
	Txid *TradeTransactionId `json:"txid,omitempty"`
}

// Time series of market trades.
type MarketTradesDataArray []MarketTrade

// MarketTradesResponse defines model for MarketTradesResponse.
type MarketTradesResponse struct {
	// Time series of market trades.
	Data MarketTradesDataArray `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Type of the market (spot, future).
type MarketType string

// List of market names.
type MarketsIds []MarketId

// List of markets.
type MarketsResponse struct {
	Data []MarketInfo `json:"data"`
}

// Maximal available block hash for time series.
type MaxHash string

// Maximal available block height for time series.
type MaxHeight string

// Maximal available time for time series.
type MaxTime string

// MempoolFeerate defines model for MempoolFeerate.
type MempoolFeerate struct {
	// Name of the asset.
	Asset    string               `json:"asset"`
	Feerates MempoolFeerateBands `json:"feerates"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// MempoolFeerateBand defines model for MempoolFeerateBand.
type MempoolFeerateBand struct {
	// Consensus sizes summed up for all the transactions included into the current mempool feerate band. vSizes sum can be derived as 'vSize = consensusSize / 4'.
	ConsensusSize MempoolFeerateBandConsensusSize `json:"consensus_size"`

	// Amount of transactions included into the current mempool feerate band.
	Count MempoolFeerateBandCount `json:"count"`

	// Rounded feerate value used to aggregate the transactions into the current mempool feerate band. Unit is sat/vB.
	Feerate MempoolFeerateBandFeerate `json:"feerate"`

	// Fees summed up for all the transactions included into the current mempool feerate band. Unit is BTC.
	Fees MempoolFeerateBandFees `json:"fees"`
}

// Consensus sizes summed up for all the transactions included into the current mempool feerate band. vSizes sum can be derived as 'vSize = consensusSize / 4'.
type MempoolFeerateBandConsensusSize string

// Amount of transactions included into the current mempool feerate band.
type MempoolFeerateBandCount string

// Rounded feerate value used to aggregate the transactions into the current mempool feerate band. Unit is sat/vB.
type MempoolFeerateBandFeerate string

// Fees summed up for all the transactions included into the current mempool feerate band. Unit is BTC.
type MempoolFeerateBandFees string

// MempoolFeerateBands defines model for MempoolFeerateBands.
type MempoolFeerateBands []MempoolFeerateBand

// MempoolFeerates defines model for MempoolFeerates.
type MempoolFeerates []MempoolFeerate

// Mempool feerates response.
type MempoolFeeratesResponse struct {
	Data MempoolFeerates `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Data Type of the metric. Can be bigint or decimal.<br/>
// "bigint" means that you should expect an integeer number in a range from -9223372036854775808 to 9223372036854775807.<br/>
// "decimal" means that a number can have up to 131072 digits before the decimal point and up to 16383 digits after the decimal point.
type MetricDataType string

// List of metric frequencies.
type MetricFrequencies []MetricFrequency

// MetricFrequency defines model for MetricFrequency.
type MetricFrequency struct {
	// List of asset names.
	Assets *AssetsIds `json:"assets,omitempty"`

	// Frequency of the metric.
	Frequency string `json:"frequency"`
}

// Name of the metric.
type MetricId string

// Information about metric.
type MetricInfo struct {
	// Category of the metric.
	Category Category `json:"category"`

	// Data Type of the metric. Can be bigint or decimal.<br/>
	// "bigint" means that you should expect an integeer number in a range from -9223372036854775808 to 9223372036854775807.<br/>
	// "decimal" means that a number can have up to 131072 digits before the decimal point and up to 16383 digits after the decimal point.
	DataType MetricDataType `json:"data_type"`

	// Human-friendly description.
	Description Description `json:"description"`

	// More detailed and human friendly name of a metric.
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// If set to true, indicates that metrics collection is under active development - there is a chance of temporary discrepancies in the served dataset.
	Experimental *ExperimentalMetric `json:"experimental,omitempty"`

	// List of metric frequencies.
	Frequencies MetricFrequencies `json:"frequencies"`

	// Human-friendly name.
	FullName FullName `json:"full_name"`

	// Name of the metric.
	Metric MetricId `json:"metric"`

	// Reviewable by human flag.
	Reviewable *Reviewable `json:"reviewable,omitempty"`

	// Subcategory of the metric.
	Subcategory Subcategory `json:"subcategory"`

	// Type of the metric.
	Type MetricType `json:"type"`

	// Unit of the metric.
	Unit Unit `json:"unit"`
}

// Type of the metric.
type MetricType string

// List of metrics.
type MetricsIds []AssetMetricInfo

// MetricsResponse defines model for MetricsResponse.
type MetricsResponse struct {
	Data []MetricInfo `json:"data"`
}

// Minimal available black hash for time series.
type MinHash string

// Minimal available block height for time series.
type MinHeight string

// Minimal available time for time series.
type MinTime string

// Information about the mining pool tips summary.
type MiningPoolTipsSummary struct {
	// Name of the asset.
	Asset string `json:"asset"`

	// The count of unique hashes at the chain tip.
	BlockHashesAtTip BlockHashesAtTip `json:"block_hashes_at_tip"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// All last tips that we saw in all mining pools that were active during the past hour.
	Tips []struct {
		// Hash of the block.
		Hash BlockchainBlockHash `json:"hash"`

		// Height of the block.
		Height BlockchainBlockHeight `json:"height"`

		// The time in ISO 8601 date-time format. Always with nanoseconds precision.
		LastTime Time `json:"last_time"`

		// The count of unique pools mining on the tip.
		PoolCount PoolCount `json:"pool_count"`
	} `json:"tips"`

	// The count of unique elements in the `tips` array.
	TipsCount TipsCount `json:"tips_count"`
}

// MiningPoolTipsSummaryResponse defines model for MiningPoolTipsSummaryResponse.
type MiningPoolTipsSummaryResponse struct {
	Data []MiningPoolTipsSummary `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// Token of the next page results for a given request.
type NextPageToken string

// URL of the next page results for a given request.
type NextPageUrl string

// A physical location of the blockchain node that have captured the transaction entering the mempool.
type NodeLocation string

// Time corresponding to open interest data point, according to the exchange. Can be NULL, if exchange doesn't support it.
type OpenInterestExchangeTime string

// 'call or 'put' option contract type.
type OptionContractType string

// Strike price for option trade.
type OptionStrike string

// Time corresponding to option ticker data point, according to the exchange. Can be NULL, if exchange doesn't support it.
type OptionTickerExchangeTime string

// The ask orders on the order book.
type OrderBookAsks []BookEntry

// The bids orders on the order book.
type OrderBookBids []BookEntry

// Time of when the order book was received from the exchange.
type OrderBookCollectTime string

// The limit price of the order on the order book.
type OrderBookPrice string

// The size of the limit order on the order book in units of the base asset.
type OrderBookSize string

// Type of the order book.
type OrderBookType string

// Pair string representation as <base>-<quote>.
type Pair string

// Unique name of the pair.
type PairId string

// Information about pair.
type PairInfo struct {
	// List of metrics.
	Metrics *PairMetricsIds `json:"metrics,omitempty"`

	// Unique name of the pair.
	Pair PairId `json:"pair"`
}

// List of metric frequencies.
type PairMetricFrequencies []PairMetricFrequency

// PairMetricFrequency defines model for PairMetricFrequency.
type PairMetricFrequency struct {
	// Frequency of the metric.
	Frequency string `json:"frequency"`

	// Maximal available time for time series.
	MaxTime MaxTime `json:"max_time"`

	// Minimal available time for time series.
	MinTime MinTime `json:"min_time"`
}

// Information about availabiliy of metric for an pair.
type PairMetricInfo struct {
	// List of metric frequencies.
	Frequencies PairMetricFrequencies `json:"frequencies"`

	// Name of the metric.
	Metric MetricId `json:"metric"`
}

// List of metrics.
type PairMetricsIds []PairMetricInfo

// Time series of pair metrics.
type PairMetricsResponse struct {
	Data interface{} `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// PairsResponse defines model for PairsResponse.
type PairsResponse struct {
	Data []PairInfo `json:"data"`
}

// The count of unique pools mining on the tip.
type PoolCount string

// The limit price of the top ask on the order book. If no asks in the order book, an entry is skipped.
type QuoteAskPrice string

// The size of the top ask on the order book. If no asks in the order book, an entry is skipped.
type QuoteAskSize string

// The limit price of the top bid on the order book. If no bids in the order book, an entry is skipped.
type QuoteBidPrice string

// The size of the top bid on the order book. If no bids in the order book, an entry is skipped.
type QuoteBidSize string

// Indicates if the last appended block triggered the chain reorganization.
type Reorg string

// A number of consecutive blocks that were disconnected from the common ancestor block of the previous and current longest active chains during the chain reorganization.
type ReorgDepth string

// Reviewable by human flag.
type Reviewable bool

// Metric values.
type StreamingAssetMetric struct {
	// Name of the asset.
	Asset string `json:"asset"`

	// The monotonically increasing message number, resets on disconnection.
	CmSequenceId CmSequenceId `json:"cm_sequence_id"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time                 Time              `json:"time"`
	AdditionalProperties map[string]string `json:"-"`
}

// StreamingMarketOrderbook defines model for StreamingMarketOrderbook.
type StreamingMarketOrderbook struct {
	// Embedded fields due to inline allOf schema
	// The ask orders on the order book.
	Asks OrderBookAsks `json:"asks"`

	// The bids orders on the order book.
	Bids OrderBookBids `json:"bids"`

	// The monotonically increasing message number, resets on disconnection.
	CmSequenceId CmSequenceId `json:"cm_sequence_id"`

	// Unique identifier of object.
	CoinMetricsId CoinMetricsId `json:"coin_metrics_id"`

	// Time of when the order book was received from the exchange.
	CollectTime OrderBookCollectTime `json:"collect_time"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// Type of the order book.
	Type OrderBookType `json:"type"`
}

// StreamingMarketQuote defines model for StreamingMarketQuote.
type StreamingMarketQuote struct {
	// Embedded struct due to allOf(#/components/schemas/MarketQuote)
	MarketQuote `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The monotonically increasing message number, resets on disconnection.
	CmSequenceId CmSequenceId `json:"cm_sequence_id"`
}

// Market trade WebSocket message.
type StreamingMarketTrade struct {
	// The amount of the base asset traded.
	Amount TradeAmount `json:"amount"`

	// The monotonically increasing message number, resets on disconnection.
	CmSequenceId CmSequenceId `json:"cm_sequence_id"`

	// ID of a trade (unique per exchange market). We are using exchange reported value if exchange reports a unique numeric trade id. If exchange reports trade id as a string we convert to numeric using Bijective mapping from exchange reported trade id's string. If exchange doesn't report unique ID we transform it using exchange reported data to form a unique value per market.
	CoinMetricsId TradesCoinMetricsId `json:"coin_metrics_id"`

	// Time of when the trade was received from the exchange.
	CollectTime TradeCollectTime `json:"collect_time"`

	// Unique name of the market.
	Market MarketId `json:"market"`

	// The price of the base asset quoted in the quote asset that the trade was executed at.
	Price TradePrice `json:"price"`

	// The market order side. "buy" means that an ask was removed from the book by an incoming buy order, "sell" means that a bid was removed from the book by an incoming sell order.
	Side *TradeSide `json:"side,omitempty"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// Subcategory of the metric.
type Subcategory string

// The time in ISO 8601 date-time format. Always with nanoseconds precision.
type Time string

// The count of unique elements in the `tips` array.
type TipsCount string

// The amount of the base asset traded.
type TradeAmount string

// Swap output receiver. Available for DeFi markets only.
type TradeBeneficiary string

// Swap block hash. Available for DeFi markets only.
type TradeBlockHash string

// Swap block height. Available for DeFi markets only.
type TradeBlockHeight string

// Time of when the trade was received from the exchange.
type TradeCollectTime string

// Swap transaction initiator. Available for DeFi markets only.
type TradeInitiator string

// The price of the base asset quoted in the quote asset that the trade was executed at.
type TradePrice string

// Swap caller. Available for DeFi markets only.
type TradeSender string

// The market order side. "buy" means that an ask was removed from the book by an incoming buy order, "sell" means that a bid was removed from the book by an incoming sell order.
type TradeSide string

// Swap transaction ID. Available for DeFi markets only.
type TradeTransactionId string

// ID of a trade (unique per exchange market). We are using exchange reported value if exchange reports a unique numeric trade id. If exchange reports trade id as a string we convert to numeric using Bijective mapping from exchange reported trade id's string. If exchange doesn't report unique ID we transform it using exchange reported data to form a unique value per market.
type TradesCoinMetricsId string

// Approximate position of the transaction in the mempool.<br/> Miners choose mempool transactions to be included in the next block by scanning mempool and sort pending transactions by feerate in descending order.<br/> The value starts with 0. A lower number means higher feerate.
type TxTrackerMempoolApproximateQueuePosition string

// The number of blocks between the transaction's block and the latest block in the blockchain plus one.<br/> If the transaction is included in the last block, the value is 1.
type TxTrackerNConfirmations string

// Approximate probability of including the mempool transaction to the next mined block.<br/> Miners choose mempool transactions to be included in the next block by scanning mempool and sort pending transactions by feerate in descending order.<br/> The value starts is a percentage between 0 and 100. A higher number means a higher probability.
type TxTrackerNextBlockApproxSettlementProbabilityPercentage string

// Why the transaction has been removed. This field is only present for `REMOVED` status. The possible values are: `EXPIRY`, `SIZE_LIMIT`, `REORG`, `CONFLICT`, `REPLACED`.
type TxTrackerRemovalReason string

// This field is set to true only if the transaction supports the replace-by-fee (RBF) feature.
type TxTrackerReplaceByFeeSupported bool

// Transaction tracker response.
type TxTrackerResponse struct {
	Data TxTrackerTransactions `json:"data"`

	// Token of the next page results for a given request.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// URL of the next page results for a given request.
	NextPageUrl *NextPageUrl `json:"next_page_url,omitempty"`
}

// TxTrackerTransaction defines model for TxTrackerTransaction.
type TxTrackerTransaction struct {
	// Hash of the block.
	BlockHash *BlockchainBlockHash `json:"block_hash,omitempty"`

	// Static information about the transaction.
	Details TxTrackerTxDetails `json:"details"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	FirstSeenTime Time                            `json:"first_seen_time"`
	Geo           BlockchainNodeLocationSeenTimes `json:"geo"`

	// Height of the block.
	Height *BlockchainBlockHeight `json:"height,omitempty"`

	// Approximate position of the transaction in the mempool.<br/> Miners choose mempool transactions to be included in the next block by scanning mempool and sort pending transactions by feerate in descending order.<br/> The value starts with 0. A lower number means higher feerate.
	MempoolApproxQueuePosition *TxTrackerMempoolApproximateQueuePosition `json:"mempool_approx_queue_position,omitempty"`

	// The number of blocks between the transaction's block and the latest block in the blockchain plus one.<br/> If the transaction is included in the last block, the value is 1.
	NConfirmations *TxTrackerNConfirmations `json:"n_confirmations,omitempty"`

	// Approximate probability of including the mempool transaction to the next mined block.<br/> Miners choose mempool transactions to be included in the next block by scanning mempool and sort pending transactions by feerate in descending order.<br/> The value starts is a percentage between 0 and 100. A higher number means a higher probability.
	NextBlockApproxSettlementProbabilityPct *TxTrackerNextBlockApproxSettlementProbabilityPercentage `json:"next_block_approx_settlement_probability_pct,omitempty"`

	// Identifier (txid) of the transaction.
	ReplacementForTxid *TxTrackerTxid `json:"replacement_for_txid,omitempty"`

	// Transaction status. Can have the following values: `UNCONFIRMED`, `REMOVED`, `CONFIRMED`.
	Status TxTrackerTxStatus `json:"status"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	StatusUpdateTime Time `json:"status_update_time"`

	// A list of status updates for the transaction.
	StatusUpdates TxTrackerTxStatusUpdates `json:"status_updates"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`

	// Identifier (txid) of the transaction.
	Txid TxTrackerTxid `json:"txid"`
}

// TxTrackerTransactions defines model for TxTrackerTransactions.
type TxTrackerTransactions []TxTrackerTransaction

// The total amount of the transaction.
type TxTrackerTxAmount string

// Static information about the transaction.
type TxTrackerTxDetails struct {
	// The total amount of the transaction.
	Amount TxTrackerTxAmount `json:"amount"`

	// Consensus size of the transaction.
	ConsensusSize *BlockchainTransactionConsensusSize `json:"consensus_size,omitempty"`

	// Fee of the transaction.
	Fee BlockchainTransactionFee `json:"fee"`

	// Feerate of the transaction.
	Feerate *BlockchainTransactionFeerate `json:"feerate,omitempty"`

	// Aggregate function result over the feerate values of all the mempool transactions.
	MempoolFeerateMeanAtFirstSeenTime *BlockchainMempoolFeerate `json:"mempool_feerate_mean_at_first_seen_time,omitempty"`

	// Aggregate function result over the feerate values of all the mempool transactions.
	MempoolFeerateMinAtFirstSeenTime *BlockchainMempoolFeerate `json:"mempool_feerate_min_at_first_seen_time,omitempty"`

	// Physical size of the transaction, bytes.
	PhysicalSize *BlockchainTransactionPhysicalSize `json:"physical_size,omitempty"`

	// This field is set to true only if the transaction supports the replace-by-fee (RBF) feature.
	ReplaceByFeeSupported TxTrackerReplaceByFeeSupported `json:"replace_by_fee_supported"`

	// Version of the transaction.
	Version BlockchainTransactionVersion `json:"version"`
}

// Transaction status. Can have the following values: `UNCONFIRMED`, `REMOVED`, `CONFIRMED`.
type TxTrackerTxStatus string

// TxTrackerTxStatusUpdate defines model for TxTrackerTxStatusUpdate.
type TxTrackerTxStatusUpdate struct {
	// Hash of the block.
	BlockHash *BlockchainBlockHash `json:"block_hash,omitempty"`

	// Height of the block.
	Height *BlockchainBlockHeight `json:"height,omitempty"`

	// Why the transaction has been removed. This field is only present for `REMOVED` status. The possible values are: `EXPIRY`, `SIZE_LIMIT`, `REORG`, `CONFLICT`, `REPLACED`.
	RemovalReason *TxTrackerRemovalReason `json:"removal_reason,omitempty"`

	// Identifier (txid) of the transaction.
	ReplacementTxid *TxTrackerTxid `json:"replacement_txid,omitempty"`

	// Transaction status. Can have the following values: `UNCONFIRMED`, `REMOVED`, `CONFIRMED`.
	Status TxTrackerTxStatus `json:"status"`

	// The time in ISO 8601 date-time format. Always with nanoseconds precision.
	Time string `json:"time"`
}

// A list of status updates for the transaction.
type TxTrackerTxStatusUpdates []TxTrackerTxStatusUpdate

// Identifier (txid) of the transaction.
type TxTrackerTxid string

// Unit of the metric.
type Unit string

// The monotonically increasing message number, resets on disconnection.
type CmSequenceId string

// AssetAlertId defines model for AssetAlertId.
type AssetAlertId []string

// AssetMetrics defines model for AssetMetrics.
type AssetMetrics []string

// AssetMetricsFrequency defines model for AssetMetricsFrequency.
type AssetMetricsFrequency string

// Backfill defines model for Backfill.
type Backfill string

// BlockchainAccounts defines model for BlockchainAccounts.
type BlockchainAccounts []string

// BlockchainAsset defines model for BlockchainAsset.
type BlockchainAsset string

// BlockchainBlockHashes defines model for BlockchainBlockHashes.
type BlockchainBlockHashes []string

// BlockchainBlockHeights defines model for BlockchainBlockHeights.
type BlockchainBlockHeights []string

// BlockchainChainType defines model for BlockchainChainType.
type BlockchainChainType string

// BlockchainEndChainSequenceNumber defines model for BlockchainEndChainSequenceNumber.
type BlockchainEndChainSequenceNumber int64

// BlockchainEndHeight defines model for BlockchainEndHeight.
type BlockchainEndHeight int64

// BlockchainEndTime defines model for BlockchainEndTime.
type BlockchainEndTime string

// BlockchainIncludeSubAccounts defines model for BlockchainIncludeSubAccounts.
type BlockchainIncludeSubAccounts bool

// BlockchainStartChainSequenceNumber defines model for BlockchainStartChainSequenceNumber.
type BlockchainStartChainSequenceNumber int64

// BlockchainStartHeight defines model for BlockchainStartHeight.
type BlockchainStartHeight int64

// BlockchainStartTime defines model for BlockchainStartTime.
type BlockchainStartTime string

// BlockchainSubAccounts defines model for BlockchainSubAccounts.
type BlockchainSubAccounts []string

// BlockchainTransactionIds defines model for BlockchainTransactionIds.
type BlockchainTransactionIds []string

// BlockchainTransactions defines model for BlockchainTransactions.
type BlockchainTransactions []string

// BookDepth defines model for BookDepth.
type BookDepth string

// CandleFrequency defines model for CandleFrequency.
type CandleFrequency string

// CatalogAssetAlertId defines model for CatalogAssetAlertId.
type CatalogAssetAlertId []string

// CatalogAssetExcludeFields defines model for CatalogAssetExcludeFields.
type CatalogAssetExcludeFields []string

// CatalogAssetId defines model for CatalogAssetId.
type CatalogAssetId []string

// CatalogAssetIncludeFields defines model for CatalogAssetIncludeFields.
type CatalogAssetIncludeFields []string

// CatalogExchangeAssetId defines model for CatalogExchangeAssetId.
type CatalogExchangeAssetId []string

// CatalogExchangeId defines model for CatalogExchangeId.
type CatalogExchangeId []string

// CatalogIndexId defines model for CatalogIndexId.
type CatalogIndexId []string

// CatalogInstitutionId defines model for CatalogInstitutionId.
type CatalogInstitutionId []string

// CatalogMarketExcludeFields defines model for CatalogMarketExcludeFields.
type CatalogMarketExcludeFields []string

// CatalogMarketFormat defines model for CatalogMarketFormat.
type CatalogMarketFormat string

// CatalogMarketId defines model for CatalogMarketId.
type CatalogMarketId []string

// CatalogMarketIncludeFields defines model for CatalogMarketIncludeFields.
type CatalogMarketIncludeFields []string

// CatalogMarketLimit defines model for CatalogMarketLimit.
type CatalogMarketLimit string

// CatalogMetric defines model for CatalogMetric.
type CatalogMetric []string

// CatalogPairId defines model for CatalogPairId.
type CatalogPairId []string

// EndHash defines model for EndHash.
type EndHash string

// EndHeight defines model for EndHeight.
type EndHeight int64

// EndInclusive defines model for EndInclusive.
type EndInclusive bool

// EndTime defines model for EndTime.
type EndTime string

// ExchangeAssetMetricsFrequency defines model for ExchangeAssetMetricsFrequency.
type ExchangeAssetMetricsFrequency string

// ExchangeAssetMetricsParam defines model for ExchangeAssetMetricsParam.
type ExchangeAssetMetricsParam []string

// ExchangeAssetSort defines model for ExchangeAssetSort.
type ExchangeAssetSort string

// ExchangeAssets defines model for ExchangeAssets.
type ExchangeAssets []string

// ExchangeMetricsFrequency defines model for ExchangeMetricsFrequency.
type ExchangeMetricsFrequency string

// ExchangeMetricsParam defines model for ExchangeMetricsParam.
type ExchangeMetricsParam []string

// ExchangeSort defines model for ExchangeSort.
type ExchangeSort string

// Exchanges defines model for Exchanges.
type Exchanges []string

// Format defines model for Format.
type Format string

// IndexConstituentsFrequency defines model for IndexConstituentsFrequency.
type IndexConstituentsFrequency string

// IndexFrequency defines model for IndexFrequency.
type IndexFrequency string

// InstitutionMetricsFrequency defines model for InstitutionMetricsFrequency.
type InstitutionMetricsFrequency string

// InstitutionMetricsParam defines model for InstitutionMetricsParam.
type InstitutionMetricsParam []string

// InstitutionSort defines model for InstitutionSort.
type InstitutionSort string

// LimitPerAsset defines model for LimitPerAsset.
type LimitPerAsset int32

// LimitPerExchange defines model for LimitPerExchange.
type LimitPerExchange int32

// LimitPerExchangeAsset defines model for LimitPerExchangeAsset.
type LimitPerExchangeAsset int32

// LimitPerIndex defines model for LimitPerIndex.
type LimitPerIndex int32

// LimitPerInstitution defines model for LimitPerInstitution.
type LimitPerInstitution int32

// LimitPerMarket defines model for LimitPerMarket.
type LimitPerMarket int32

// LimitPerPair defines model for LimitPerPair.
type LimitPerPair int32

// MarketAsset defines model for MarketAsset.
type MarketAsset string

// MarketBase defines model for MarketBase.
type MarketBase string

// MarketMetricsFrequency defines model for MarketMetricsFrequency.
type MarketMetricsFrequency string

// MarketMetricsParam defines model for MarketMetricsParam.
type MarketMetricsParam []string

// MarketMetricsSort defines model for MarketMetricsSort.
type MarketMetricsSort string

// Markets defines model for Markets.
type Markets []string

// MempoolFeeratesPageSize defines model for MempoolFeeratesPageSize.
type MempoolFeeratesPageSize int32

// MinConfirmations defines model for MinConfirmations.
type MinConfirmations int32

// NullAsZero defines model for NullAsZero.
type NullAsZero bool

// OnlyReplacementTransactions defines model for OnlyReplacementTransactions.
type OnlyReplacementTransactions bool

// PageSize defines model for PageSize.
type PageSize int32

// PagingFrom defines model for PagingFrom.
type PagingFrom string

// PairMetricsFrequency defines model for PairMetricsFrequency.
type PairMetricsFrequency string

// PairMetricsParam defines model for PairMetricsParam.
type PairMetricsParam []string

// PairSort defines model for PairSort.
type PairSort string

// Pretty defines model for Pretty.
type Pretty bool

// ReplacementsForTransactions defines model for ReplacementsForTransactions.
type ReplacementsForTransactions []string

// Sort defines model for Sort.
type Sort string

// StartHash defines model for StartHash.
type StartHash string

// StartHeight defines model for StartHeight.
type StartHeight int64

// StartInclusive defines model for StartInclusive.
type StartInclusive bool

// StartTime defines model for StartTime.
type StartTime string

// Status defines model for Status.
type Status string

// StreamAssetMetricsFrequency defines model for StreamAssetMetricsFrequency.
type StreamAssetMetricsFrequency string

// Timezone defines model for Timezone.
type Timezone string

// TradeMinConfirmations defines model for TradeMinConfirmations.
type TradeMinConfirmations int32

// AssetAlertNotFound defines model for AssetAlertNotFound.
type AssetAlertNotFound ErrorResponse

// AssetAlertRules defines model for AssetAlertRules.
type AssetAlertRules AssetAlertRulesResponse

// AssetNotFound defines model for AssetNotFound.
type AssetNotFound ErrorResponse

// Assets defines model for Assets.
type Assets AssetsResponse

// Blockchain accounts response.
type BlockchainAccountsV2 BlockchainAccountsResponseV2

// Blockchain blocks response.
type BlockchainBlocks BlockchainBlocksResponse

// Blockchain blocks response.
type BlockchainBlocksV2 BlockchainBlocksResponseV2

// BlockchainForbidden defines model for BlockchainForbidden.
type BlockchainForbidden ErrorResponse

// BlockchainFullBlock defines model for BlockchainFullBlock.
type BlockchainFullBlock BlockchainFullBlockResponse

// BlockchainFullBlockV2 defines model for BlockchainFullBlockV2.
type BlockchainFullBlockV2 BlockchainFullBlockResponseV2

// BlockchainFullTransaction defines model for BlockchainFullTransaction.
type BlockchainFullTransaction BlockchainFullSingleTransactionResponse

// BlockchainFullTransactionV2 defines model for BlockchainFullTransactionV2.
type BlockchainFullTransactionV2 BlockchainFullSingleTransactionResponseV2

// Blockchain sub-accounts response.
type BlockchainSubAccountsV2 BlockchainSubAccountsResponseV2

// Blockchain transactions response.
type BlockchainTransactionsV2 BlockchainTransactionsResponseV2

// List of market candles statistics.
type CatalogMarketCandles CatalogMarketCandlesResponse

// List of market metrics statistics.
type CatalogMarketMetrics CatalogMarketMetricsResponse

// Time series of exchange metrics.
type ExchangeAssetMetrics ExchangeAssetMetricsResponse

// ExchangeAssetNotFound defines model for ExchangeAssetNotFound.
type ExchangeAssetNotFound ErrorResponse

// Time series of Exchange metrics.
type ExchangeMetrics ExchangeMetricsResponse

// ExchangeNotFound defines model for ExchangeNotFound.
type ExchangeNotFound ErrorResponse

// Forbidden defines model for Forbidden.
type Forbidden ErrorResponse

// IndexLevels defines model for IndexLevels.
type IndexLevels IndexLevelsResponse

// IndexNotFound defines model for IndexNotFound.
type IndexNotFound ErrorResponse

// Indexes defines model for Indexes.
type Indexes IndexesResponse

// Time series of institution metrics.
type InstitutionMetrics InstitutionMetricsResponse

// InstitutionNotFound defines model for InstitutionNotFound.
type InstitutionNotFound ErrorResponse

// Institutions defines model for Institutions.
type Institutions InstitutionsResponse

// MarketCandles defines model for MarketCandles.
type MarketCandles MarketCandlesResponse

// MarketFundingRates defines model for MarketFundingRates.
type MarketFundingRates MarketFundingRatesResponse

// MarketLiquidations defines model for MarketLiquidations.
type MarketLiquidations MarketLiquidationsResponse

// Time series of market metrics.
type MarketMetrics MarketMetricsResponse

// MarketNotFound defines model for MarketNotFound.
type MarketNotFound ErrorResponse

// MarketOrderBooks defines model for MarketOrderBooks.
type MarketOrderBooks MarketOrderbookResponse

// MarketQuotes defines model for MarketQuotes.
type MarketQuotes MarketQuotesResponse

// MarketTrades defines model for MarketTrades.
type MarketTrades MarketTradesResponse

// MetricNotFound defines model for MetricNotFound.
type MetricNotFound ErrorResponse

// Metrics defines model for Metrics.
type Metrics MetricsResponse

// Time series of pair metrics.
type PairMetrics PairMetricsResponse

// PairNotFound defines model for PairNotFound.
type PairNotFound ErrorResponse

// Pairs defines model for Pairs.
type Pairs PairsResponse

// Metric values.
type StreamingAssetMetrics StreamingAssetMetric

// StreamingMarketOrderbooks defines model for StreamingMarketOrderbooks.
type StreamingMarketOrderbooks StreamingMarketOrderbook

// StreamingMarketQuotes defines model for StreamingMarketQuotes.
type StreamingMarketQuotes StreamingMarketQuote

// Market trade WebSocket message.
type StreamingMarketTrades StreamingMarketTrade

// Transaction tracker response.
type TxTracker TxTrackerResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized ErrorResponse

// GetBlockchainV2ListOfAccountsParams defines parameters for GetBlockchainV2ListOfAccounts.
type GetBlockchainV2ListOfAccountsParams struct {
	// Optional comma separated list of accounts to filter a response.
	Accounts *BlockchainAccounts `json:"accounts,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Start of the `chain_sequence_number` interval.
	StartChainSequenceNumber *BlockchainStartChainSequenceNumber `json:"start_chain_sequence_number,omitempty"`

	// End of the `chain_sequence_number` interval.
	EndChainSequenceNumber *BlockchainEndChainSequenceNumber `json:"end_chain_sequence_number,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainV2ListOfAccountsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainV2ListOfAccountsParamsPagingFrom defines parameters for GetBlockchainV2ListOfAccounts.
type GetBlockchainV2ListOfAccountsParamsPagingFrom string

// GetBlockchainV2ListOfBalanceUpdatesParams defines parameters for GetBlockchainV2ListOfBalanceUpdates.
type GetBlockchainV2ListOfBalanceUpdatesParams struct {
	// Optional comma separated list of accounts to filter a response.
	Accounts *BlockchainAccounts `json:"accounts,omitempty"`

	// Optional comma separated list of sub-accounts to filter a response.
	SubAccounts *BlockchainSubAccounts `json:"sub_accounts,omitempty"`

	// Optional comma separated list of transaction identifiers (txid) to filter a response.
	Txids *BlockchainTransactionIds `json:"txids,omitempty"`

	// Optional comma separated list of block hashes to filter a response.
	BlockHashes *BlockchainBlockHashes `json:"block_hashes,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Start of the `chain_sequence_number` interval.
	StartChainSequenceNumber *BlockchainStartChainSequenceNumber `json:"start_chain_sequence_number,omitempty"`

	// End of the `chain_sequence_number` interval.
	EndChainSequenceNumber *BlockchainEndChainSequenceNumber `json:"end_chain_sequence_number,omitempty"`

	// Boolean indicating if the response should contain sub-accounts.
	IncludeSubAccounts *BlockchainIncludeSubAccounts `json:"include_sub_accounts,omitempty"`

	// Chain type. Supported values are `main` and `all` (includes both main and stale).
	Chain *BlockchainChainType `json:"chain,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainV2ListOfBalanceUpdatesParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainV2ListOfBalanceUpdatesParamsPagingFrom defines parameters for GetBlockchainV2ListOfBalanceUpdates.
type GetBlockchainV2ListOfBalanceUpdatesParamsPagingFrom string

// GetBlockchainV2ListOfBlocksParams defines parameters for GetBlockchainV2ListOfBlocks.
type GetBlockchainV2ListOfBlocksParams struct {
	// Optional comma separated list of block hashes to filter a response.
	BlockHashes *BlockchainBlockHashes `json:"block_hashes,omitempty"`

	// Optional comma separated list of block heights to filter a response.
	Heights *BlockchainBlockHeights `json:"heights,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Chain type. Supported values are `main` and `all` (includes both main and stale).
	Chain *BlockchainChainType `json:"chain,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainV2ListOfBlocksParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainV2ListOfBlocksParamsPagingFrom defines parameters for GetBlockchainV2ListOfBlocks.
type GetBlockchainV2ListOfBlocksParamsPagingFrom string

// GetBlockchainV2FullBlockParams defines parameters for GetBlockchainV2FullBlock.
type GetBlockchainV2FullBlockParams struct {
	// Boolean indicating if the response should contain sub-accounts.
	IncludeSubAccounts *BlockchainIncludeSubAccounts `json:"include_sub_accounts,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetBlockchainV2FullTransactionForBlockParams defines parameters for GetBlockchainV2FullTransactionForBlock.
type GetBlockchainV2FullTransactionForBlockParams struct {
	// Boolean indicating if the response should contain sub-accounts.
	IncludeSubAccounts *BlockchainIncludeSubAccounts `json:"include_sub_accounts,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetBlockchainV2ListOfSubAccountsParams defines parameters for GetBlockchainV2ListOfSubAccounts.
type GetBlockchainV2ListOfSubAccountsParams struct {
	// Optional comma separated list of accounts to filter a response.
	Accounts *BlockchainAccounts `json:"accounts,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Start of the `chain_sequence_number` interval.
	StartChainSequenceNumber *BlockchainStartChainSequenceNumber `json:"start_chain_sequence_number,omitempty"`

	// End of the `chain_sequence_number` interval.
	EndChainSequenceNumber *BlockchainEndChainSequenceNumber `json:"end_chain_sequence_number,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainV2ListOfSubAccountsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainV2ListOfSubAccountsParamsPagingFrom defines parameters for GetBlockchainV2ListOfSubAccounts.
type GetBlockchainV2ListOfSubAccountsParamsPagingFrom string

// GetBlockchainV2ListOfTransactionsParams defines parameters for GetBlockchainV2ListOfTransactions.
type GetBlockchainV2ListOfTransactionsParams struct {
	// Optional comma separated list of transaction identifiers (txid) to filter a response.
	Txids *BlockchainTransactionIds `json:"txids,omitempty"`

	// Optional comma separated list of block hashes to filter a response.
	BlockHashes *BlockchainBlockHashes `json:"block_hashes,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Chain type. Supported values are `main` and `all` (includes both main and stale).
	Chain *BlockchainChainType `json:"chain,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainV2ListOfTransactionsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainV2ListOfTransactionsParamsPagingFrom defines parameters for GetBlockchainV2ListOfTransactions.
type GetBlockchainV2ListOfTransactionsParamsPagingFrom string

// GetBlockchainV2FullTransactionParams defines parameters for GetBlockchainV2FullTransaction.
type GetBlockchainV2FullTransactionParams struct {
	// Boolean indicating if the response should contain sub-accounts.
	IncludeSubAccounts *BlockchainIncludeSubAccounts `json:"include_sub_accounts,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetBlockchainListOfAccountsParams defines parameters for GetBlockchainListOfAccounts.
type GetBlockchainListOfAccountsParams struct {
	// Optional comma separated list of accounts to filter a response.
	Accounts *BlockchainAccounts `json:"accounts,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Start of the `chain_sequence_number` interval.
	StartChainSequenceNumber *BlockchainStartChainSequenceNumber `json:"start_chain_sequence_number,omitempty"`

	// End of the `chain_sequence_number` interval.
	EndChainSequenceNumber *BlockchainEndChainSequenceNumber `json:"end_chain_sequence_number,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainListOfAccountsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainListOfAccountsParamsPagingFrom defines parameters for GetBlockchainListOfAccounts.
type GetBlockchainListOfAccountsParamsPagingFrom string

// GetBlockchainListOfBalanceUpdatesParams defines parameters for GetBlockchainListOfBalanceUpdates.
type GetBlockchainListOfBalanceUpdatesParams struct {
	// Optional comma separated list of accounts to filter a response.
	Accounts *BlockchainAccounts `json:"accounts,omitempty"`

	// Optional comma separated list of transaction hashes to filter a response.
	TransactionHashes *BlockchainTransactions `json:"transaction_hashes,omitempty"`

	// Optional comma separated list of block hashes to filter a response.
	BlockHashes *BlockchainBlockHashes `json:"block_hashes,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Start of the `chain_sequence_number` interval.
	StartChainSequenceNumber *BlockchainStartChainSequenceNumber `json:"start_chain_sequence_number,omitempty"`

	// End of the `chain_sequence_number` interval.
	EndChainSequenceNumber *BlockchainEndChainSequenceNumber `json:"end_chain_sequence_number,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainListOfBalanceUpdatesParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainListOfBalanceUpdatesParamsPagingFrom defines parameters for GetBlockchainListOfBalanceUpdates.
type GetBlockchainListOfBalanceUpdatesParamsPagingFrom string

// GetBlockchainListOfBlocksParams defines parameters for GetBlockchainListOfBlocks.
type GetBlockchainListOfBlocksParams struct {
	// Optional comma separated list of block hashes to filter a response.
	BlockHashes *BlockchainBlockHashes `json:"block_hashes,omitempty"`

	// Optional comma separated list of block heights to filter a response.
	Heights *BlockchainBlockHeights `json:"heights,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainListOfBlocksParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainListOfBlocksParamsPagingFrom defines parameters for GetBlockchainListOfBlocks.
type GetBlockchainListOfBlocksParamsPagingFrom string

// GetBlockchainFullBlockParams defines parameters for GetBlockchainFullBlock.
type GetBlockchainFullBlockParams struct {
	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetBlockchainFullTransactionForBlockParams defines parameters for GetBlockchainFullTransactionForBlock.
type GetBlockchainFullTransactionForBlockParams struct {
	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetTransactionTrackerParams defines parameters for GetTransactionTracker.
type GetTransactionTrackerParams struct {
	// Comma separated list of transaction identifiers (txid) to track.
	Txids *TxTrackerTransactions `json:"txids,omitempty"`

	// Comma separated list of transaction identifiers (txid) to get the corresponding replacement transactions for.<br/> Mutually exclusive with `txids`.<br/>
	ReplacementsForTxids *ReplacementsForTransactions `json:"replacements_for_txids,omitempty"`

	// Boolean indicating if the response should contain only the replacement transactions.
	ReplacementsOnly *OnlyReplacementTransactions `json:"replacements_only,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTransactionTrackerParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTransactionTrackerParamsPagingFrom defines parameters for GetTransactionTracker.
type GetTransactionTrackerParamsPagingFrom string

// GetBlockchainListOfTransactionsParams defines parameters for GetBlockchainListOfTransactions.
type GetBlockchainListOfTransactionsParams struct {
	// Optional comma separated list of transaction hashes to filter a response.
	TransactionHashes *BlockchainTransactions `json:"transaction_hashes,omitempty"`

	// Optional comma separated list of block hashes to filter a response.
	BlockHashes *BlockchainBlockHashes `json:"block_hashes,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *BlockchainStartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *BlockchainEndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time`.
	StartHeight *BlockchainStartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time`.
	EndHeight *BlockchainEndHeight `json:"end_height,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetBlockchainListOfTransactionsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetBlockchainListOfTransactionsParamsPagingFrom defines parameters for GetBlockchainListOfTransactions.
type GetBlockchainListOfTransactionsParamsPagingFrom string

// GetBlockchainFullTransactionParams defines parameters for GetBlockchainFullTransaction.
type GetBlockchainFullTransactionParams struct {
	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllAssetAlertRulesParams defines parameters for GetCatalogAllAssetAlertRules.
type GetCatalogAllAssetAlertRulesParams struct {
	// Comma separated list of assets. By default all assets are returned.
	Assets *CatalogAssetId `json:"assets,omitempty"`

	// Comma separated list of asset alert names. By default all asset alerts are returned.
	Alerts *CatalogAssetAlertId `json:"alerts,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllAssetsParams defines parameters for GetCatalogAllAssets.
type GetCatalogAllAssetsParams struct {
	// Comma separated list of assets. By default all assets are returned.
	Assets *CatalogAssetId `json:"assets,omitempty"`

	// Comma separated list of fields to include in response. Supported values are `metrics`, `markets`, `exchanges`. Included by default if omitted.
	Include *CatalogAssetIncludeFields `json:"include,omitempty"`

	// Comma separated list of fields to exclude from response. Supported values are `metrics`, `markets`, `exchanges`. Included by default if omitted.
	Exclude *CatalogAssetExcludeFields `json:"exclude,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllExchangeAssetsParams defines parameters for GetCatalogAllExchangeAssets.
type GetCatalogAllExchangeAssetsParams struct {
	// Comma separated list of exchange-assets. By default, all exchange-assets pairs are returned.
	ExchangeAssets *CatalogExchangeAssetId `json:"exchange_assets,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllExchangesParams defines parameters for GetCatalogAllExchanges.
type GetCatalogAllExchangesParams struct {
	// Comma separated list of exchanges. By default all exchanges are returned.
	Exchanges *CatalogExchangeId `json:"exchanges,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllIndexesParams defines parameters for GetCatalogAllIndexes.
type GetCatalogAllIndexesParams struct {
	// Comma separated list of indexes. By default all assets are returned.
	Indexes *CatalogIndexId `json:"indexes,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllInstitutionsParams defines parameters for GetCatalogAllInstitutions.
type GetCatalogAllInstitutionsParams struct {
	// Comma separated list of institutions. By default, all institutions are returned.
	Institutions *CatalogInstitutionId `json:"institutions,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllMarketCandlesParams defines parameters for GetCatalogAllMarketCandles.
type GetCatalogAllMarketCandlesParams struct {
	// Comma separated list of markets. By default all markets are returned.
	Markets *CatalogMarketId `json:"markets,omitempty"`

	// Unique name of an exchange.
	Exchange *string `json:"exchange,omitempty"`

	// Type of markets.
	Type *GetCatalogAllMarketCandlesParamsType `json:"type,omitempty"`

	// Base asset of markets.
	Base *MarketBase `json:"base,omitempty"`

	// Quote asset of markets.
	Quote *MarketQuote `json:"quote,omitempty"`

	// Any asset of markets.
	Asset *MarketAsset `json:"asset,omitempty"`

	// Symbol of derivative markets, full instrument name.
	Symbol *MarketSymbol `json:"symbol,omitempty"`

	// Format of the response. Supported values are `json`, `json_stream`.
	Format *CatalogMarketFormat `json:"format,omitempty"`

	// Limit of response items. `none` means no limit.
	Limit *CatalogMarketLimit `json:"limit,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllMarketCandlesParamsType defines parameters for GetCatalogAllMarketCandles.
type GetCatalogAllMarketCandlesParamsType string

// GetCatalogAllMarketMetricsParams defines parameters for GetCatalogAllMarketMetrics.
type GetCatalogAllMarketMetricsParams struct {
	// Comma separated list of markets. By default all markets are returned.
	Markets *CatalogMarketId `json:"markets,omitempty"`

	// Unique name of an exchange.
	Exchange *string `json:"exchange,omitempty"`

	// Type of markets.
	Type *GetCatalogAllMarketMetricsParamsType `json:"type,omitempty"`

	// Base asset of markets.
	Base *MarketBase `json:"base,omitempty"`

	// Quote asset of markets.
	Quote *MarketQuote `json:"quote,omitempty"`

	// Any asset of markets.
	Asset *MarketAsset `json:"asset,omitempty"`

	// Symbol of derivative markets, full instrument name.
	Symbol *MarketSymbol `json:"symbol,omitempty"`

	// Format of the response. Supported values are `json`, `json_stream`.
	Format *CatalogMarketFormat `json:"format,omitempty"`

	// Limit of response items. `none` means no limit.
	Limit *CatalogMarketLimit `json:"limit,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllMarketMetricsParamsType defines parameters for GetCatalogAllMarketMetrics.
type GetCatalogAllMarketMetricsParamsType string

// GetCatalogAllMarketsParams defines parameters for GetCatalogAllMarkets.
type GetCatalogAllMarketsParams struct {
	// Comma separated list of markets. By default all markets are returned.
	Markets *CatalogMarketId `json:"markets,omitempty"`

	// Unique name of an exchange.
	Exchange *string `json:"exchange,omitempty"`

	// Type of markets.
	Type *GetCatalogAllMarketsParamsType `json:"type,omitempty"`

	// Base asset of markets.
	Base *MarketBase `json:"base,omitempty"`

	// Quote asset of markets.
	Quote *MarketQuote `json:"quote,omitempty"`

	// Any asset of markets.
	Asset *MarketAsset `json:"asset,omitempty"`

	// Symbol of derivative markets, full instrument name.
	Symbol *MarketSymbol `json:"symbol,omitempty"`

	// Comma separated list of fields to include in response. Supported values are `trades`, `orderbooks`, `quotes`, `candles`, `funding_rates`, `openinterest`, `liquidations`. Included by default if omitted.
	Include *CatalogMarketIncludeFields `json:"include,omitempty"`

	// Comma separated list of fields to exclude from response. Supported values are `trades`, `orderbooks`, `quotes`, `candles`, `funding_rates`, `openinterest`, `liquidations`. Included by default if omitted.
	Exclude *CatalogMarketExcludeFields `json:"exclude,omitempty"`

	// Format of the response. Supported values are `json`, `json_stream`.
	Format *CatalogMarketFormat `json:"format,omitempty"`

	// Limit of response items. `none` means no limit.
	Limit *CatalogMarketLimit `json:"limit,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllMarketsParamsType defines parameters for GetCatalogAllMarkets.
type GetCatalogAllMarketsParamsType string

// GetCatalogAllMetricsParams defines parameters for GetCatalogAllMetrics.
type GetCatalogAllMetricsParams struct {
	// Comma separated list of metrics. By default all metrics are returned.
	Metrics *CatalogMetric `json:"metrics,omitempty"`

	// Limit to human-reviewable metrics. By default all metrics are returned.
	Reviewable *Reviewable `json:"reviewable,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAllAssetPairsParams defines parameters for GetCatalogAllAssetPairs.
type GetCatalogAllAssetPairsParams struct {
	// Comma separated list of asset pairs. By default, all asset pairs are returned.
	Pairs *CatalogPairId `json:"pairs,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAssetAlertRulesParams defines parameters for GetCatalogAssetAlertRules.
type GetCatalogAssetAlertRulesParams struct {
	// Comma separated list of assets. By default all assets are returned.
	Assets *CatalogAssetId `json:"assets,omitempty"`

	// Comma separated list of asset alert names. By default all asset alerts are returned.
	Alerts *CatalogAssetAlertId `json:"alerts,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAssetsParams defines parameters for GetCatalogAssets.
type GetCatalogAssetsParams struct {
	// Comma separated list of assets. By default all assets are returned.
	Assets *CatalogAssetId `json:"assets,omitempty"`

	// Comma separated list of fields to include in response. Supported values are `metrics`, `markets`, `exchanges`. Included by default if omitted.
	Include *CatalogAssetIncludeFields `json:"include,omitempty"`

	// Comma separated list of fields to exclude from response. Supported values are `metrics`, `markets`, `exchanges`. Included by default if omitted.
	Exclude *CatalogAssetExcludeFields `json:"exclude,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogExchangeAssetsParams defines parameters for GetCatalogExchangeAssets.
type GetCatalogExchangeAssetsParams struct {
	// Comma separated list of exchange-assets. By default, all exchange-assets pairs are returned.
	ExchangeAssets *CatalogExchangeAssetId `json:"exchange_assets,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogExchangesParams defines parameters for GetCatalogExchanges.
type GetCatalogExchangesParams struct {
	// Comma separated list of exchanges. By default all exchanges are returned.
	Exchanges *CatalogExchangeId `json:"exchanges,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogIndexesParams defines parameters for GetCatalogIndexes.
type GetCatalogIndexesParams struct {
	// Comma separated list of indexes. By default all assets are returned.
	Indexes *CatalogIndexId `json:"indexes,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogInstitutionsParams defines parameters for GetCatalogInstitutions.
type GetCatalogInstitutionsParams struct {
	// Comma separated list of institutions. By default, all institutions are returned.
	Institutions *CatalogInstitutionId `json:"institutions,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogMarketCandlesParams defines parameters for GetCatalogMarketCandles.
type GetCatalogMarketCandlesParams struct {
	// Comma separated list of markets. By default all markets are returned.
	Markets *CatalogMarketId `json:"markets,omitempty"`

	// Unique name of an exchange.
	Exchange *string `json:"exchange,omitempty"`

	// Type of markets.
	Type *GetCatalogMarketCandlesParamsType `json:"type,omitempty"`

	// Base asset of markets.
	Base *MarketBase `json:"base,omitempty"`

	// Quote asset of markets.
	Quote *MarketQuote `json:"quote,omitempty"`

	// Any asset of markets.
	Asset *MarketAsset `json:"asset,omitempty"`

	// Symbol of derivative markets, full instrument name.
	Symbol *MarketSymbol `json:"symbol,omitempty"`

	// Format of the response. Supported values are `json`, `json_stream`.
	Format *CatalogMarketFormat `json:"format,omitempty"`

	// Limit of response items. `none` means no limit.
	Limit *CatalogMarketLimit `json:"limit,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogMarketCandlesParamsType defines parameters for GetCatalogMarketCandles.
type GetCatalogMarketCandlesParamsType string

// GetCatalogMarketMetricsParams defines parameters for GetCatalogMarketMetrics.
type GetCatalogMarketMetricsParams struct {
	// Comma separated list of markets. By default all markets are returned.
	Markets *CatalogMarketId `json:"markets,omitempty"`

	// Unique name of an exchange.
	Exchange *string `json:"exchange,omitempty"`

	// Type of markets.
	Type *GetCatalogMarketMetricsParamsType `json:"type,omitempty"`

	// Base asset of markets.
	Base *MarketBase `json:"base,omitempty"`

	// Quote asset of markets.
	Quote *MarketQuote `json:"quote,omitempty"`

	// Any asset of markets.
	Asset *MarketAsset `json:"asset,omitempty"`

	// Symbol of derivative markets, full instrument name.
	Symbol *MarketSymbol `json:"symbol,omitempty"`

	// Format of the response. Supported values are `json`, `json_stream`.
	Format *CatalogMarketFormat `json:"format,omitempty"`

	// Limit of response items. `none` means no limit.
	Limit *CatalogMarketLimit `json:"limit,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogMarketMetricsParamsType defines parameters for GetCatalogMarketMetrics.
type GetCatalogMarketMetricsParamsType string

// GetCatalogMarketsParams defines parameters for GetCatalogMarkets.
type GetCatalogMarketsParams struct {
	// Comma separated list of markets. By default all markets are returned.
	Markets *CatalogMarketId `json:"markets,omitempty"`

	// Unique name of an exchange.
	Exchange *string `json:"exchange,omitempty"`

	// Type of markets.
	Type *GetCatalogMarketsParamsType `json:"type,omitempty"`

	// Base asset of markets.
	Base *MarketBase `json:"base,omitempty"`

	// Quote asset of markets.
	Quote *MarketQuote `json:"quote,omitempty"`

	// Any asset of markets.
	Asset *MarketAsset `json:"asset,omitempty"`

	// Symbol of derivative markets, full instrument name.
	Symbol *MarketSymbol `json:"symbol,omitempty"`

	// Comma separated list of fields to include in response. Supported values are `trades`, `orderbooks`, `quotes`, `candles`, `funding_rates`, `openinterest`, `liquidations`. Included by default if omitted.
	Include *CatalogMarketIncludeFields `json:"include,omitempty"`

	// Comma separated list of fields to exclude from response. Supported values are `trades`, `orderbooks`, `quotes`, `candles`, `funding_rates`, `openinterest`, `liquidations`. Included by default if omitted.
	Exclude *CatalogMarketExcludeFields `json:"exclude,omitempty"`

	// Format of the response. Supported values are `json`, `json_stream`.
	Format *CatalogMarketFormat `json:"format,omitempty"`

	// Limit of response items. `none` means no limit.
	Limit *CatalogMarketLimit `json:"limit,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogMarketsParamsType defines parameters for GetCatalogMarkets.
type GetCatalogMarketsParamsType string

// GetCatalogMetricsParams defines parameters for GetCatalogMetrics.
type GetCatalogMetricsParams struct {
	// Comma separated list of metrics. By default all metrics are returned.
	Metrics *CatalogMetric `json:"metrics,omitempty"`

	// Limit to human-reviewable metrics. By default all metrics are returned.
	Reviewable *Reviewable `json:"reviewable,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetCatalogAssetPairsParams defines parameters for GetCatalogAssetPairs.
type GetCatalogAssetPairsParams struct {
	// Comma separated list of asset pairs. By default, all asset pairs are returned.
	Pairs *CatalogPairId `json:"pairs,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetTimeseriesStreamAssetMetricsParams defines parameters for GetTimeseriesStreamAssetMetrics.
type GetTimeseriesStreamAssetMetricsParams struct {
	// Comma separated list of assets.<br/> Use the [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported assets.
	Assets AssetId `json:"assets"`

	// Comma separated metrics to request time series data for.<br/> Information on all available metrics can be found on page https://docs.coinmetrics.io/info/metrics.<br/> Use the [/catalog-all/metrics](#operation/getCatalogAllMetrics) or [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported metrics per asset.
	Metrics AssetMetrics `json:"metrics"`

	// Frequency of the metrics. Supported values are `1b` (block by block), `1s`.
	Frequency *StreamAssetMetricsFrequency `json:"frequency,omitempty"`

	// What data should be sent upon a connection.<br/> By default the latest values are sent just before real-time data.
	Backfill *GetTimeseriesStreamAssetMetricsParamsBackfill `json:"backfill,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetTimeseriesStreamAssetMetricsParamsBackfill defines parameters for GetTimeseriesStreamAssetMetrics.
type GetTimeseriesStreamAssetMetricsParamsBackfill string

// GetTimeseriesStreamMarketOrderbooksParams defines parameters for GetTimeseriesStreamMarketOrderbooks.
type GetTimeseriesStreamMarketOrderbooksParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// What data should be sent upon a connection.<br/> By default the latest values are sent just before real-time data.
	Backfill *GetTimeseriesStreamMarketOrderbooksParamsBackfill `json:"backfill,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetTimeseriesStreamMarketOrderbooksParamsBackfill defines parameters for GetTimeseriesStreamMarketOrderbooks.
type GetTimeseriesStreamMarketOrderbooksParamsBackfill string

// GetTimeseriesStreamMarketQuotesParams defines parameters for GetTimeseriesStreamMarketQuotes.
type GetTimeseriesStreamMarketQuotesParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// What data should be sent upon a connection.<br/> By default the latest values are sent just before real-time data.
	Backfill *GetTimeseriesStreamMarketQuotesParamsBackfill `json:"backfill,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetTimeseriesStreamMarketQuotesParamsBackfill defines parameters for GetTimeseriesStreamMarketQuotes.
type GetTimeseriesStreamMarketQuotesParamsBackfill string

// GetTimeseriesStreamMarketTradesParams defines parameters for GetTimeseriesStreamMarketTrades.
type GetTimeseriesStreamMarketTradesParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// What data should be sent upon a connection.<br/> By default the latest values are sent just before real-time data.
	Backfill *GetTimeseriesStreamMarketTradesParamsBackfill `json:"backfill,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`
}

// GetTimeseriesStreamMarketTradesParamsBackfill defines parameters for GetTimeseriesStreamMarketTrades.
type GetTimeseriesStreamMarketTradesParamsBackfill string

// GetAssetAlertsParams defines parameters for GetAssetAlerts.
type GetAssetAlertsParams struct {
	// Comma separated list of assets.<br/> Use the [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported assets.
	Assets AssetId `json:"assets"`

	// Comma separated list of asset alert names.<br/> Use the [/catalog-all/alerts](#operation/getCatalogAllAssetAlerts) endpoint for the full list of supported asset alerts.
	Alerts AssetAlertId `json:"alerts"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetAssetAlertsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetAssetAlertsParamsPagingFrom defines parameters for GetAssetAlerts.
type GetAssetAlertsParamsPagingFrom string

// GetAssetChainsParams defines parameters for GetAssetChains.
type GetAssetChainsParams struct {
	// Comma separated list of assets.<br/> Use the [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported assets.
	Assets AssetId `json:"assets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetAssetChainsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetAssetChainsParamsPagingFrom defines parameters for GetAssetChains.
type GetAssetChainsParamsPagingFrom string

// GetTimeseriesAssetMetricsParams defines parameters for GetTimeseriesAssetMetrics.
type GetTimeseriesAssetMetricsParams struct {
	// Comma separated list of assets.<br/> Use the [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported assets.
	Assets AssetId `json:"assets"`

	// Comma separated metrics to request time series data for.<br/> Information on all available metrics can be found on page https://docs.coinmetrics.io/info/metrics.<br/> Use the [/catalog-all/metrics](#operation/getCatalogAllMetrics) or [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported metrics per asset.
	Metrics AssetMetrics `json:"metrics"`

	// Frequency of the metrics. Supported values are `1b` (block by block), `1s` (one second), `1m` (one minute), `1h` (one hour), `1d` (one day), `1d-ny-close` (one day at New York close time). Please refer to the `/catalog/metrics` endpoint for the full list.<br/> Use the [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported frequencies per asset-metric pair.
	Frequency *AssetMetricsFrequency `json:"frequency,omitempty"`

	// Which metric values do you want to see. Applicable only for "reviewable" metrics. You can find them in the `/catalog/metrics` endpoint.
	Status *GetTimeseriesAssetMetricsParamsStatus `json:"status,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// The start height indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time` and `start_hash`.
	StartHeight *StartHeight `json:"start_height,omitempty"`

	// The end height indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time` and `end_hash`.
	EndHeight *EndHeight `json:"end_height,omitempty"`

	// The start hash indicates the beginning block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `start_time` and `start_height`.
	StartHash *StartHash `json:"start_hash,omitempty"`

	// The end hash indicates the ending block height for the set of data that are returned.<br/> Inclusive by default. Mutually exclusive with `end_time` and `end_height`.
	EndHash *EndHash `json:"end_hash,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Specifies how many blocks behind the chain tip block by block metrics (`1b` frequency) are based on. Default for `btc` is `2` and `99` for `eth`. For example, a `min_confirmations` of `0` means metrics are being calculated for the block at the tip of the chain (the latest block received by our node) whereas a `min_confirmations` of `6` means that metrics are being applied to the block that is `6` blocks behind the chain tip (i.e., the 7th block if the chain tip is block 1).
	MinConfirmations *MinConfirmations `json:"min_confirmations,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesAssetMetricsParamsPagingFrom `json:"paging_from,omitempty"`

	// How results will be sorted. Metrics with `1b` frequency are sorted by `(asset, height, block_hash)` tuples by default. Metrics with other frequencies are sorted by `(asset, time)` by default. If you want to sort `1d` metrics by `(time, asset)` you should choose `time` as value for the `sort` parameter.<br/> Sorting by `time` is useful if you request metrics for a set of assets.
	Sort *GetTimeseriesAssetMetricsParamsSort `json:"sort,omitempty"`

	// How many entries per asset result should contain. For example, this combination of parameters `assets=btc,eth&metrics=ReferenceRate&limit_per_asset=1` returns the latest `ReferenceRate` values for `btc` and `eth`.
	LimitPerAsset *LimitPerAsset `json:"limit_per_asset,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Format of the response.
	Format *GetTimeseriesAssetMetricsParamsFormat `json:"format,omitempty"`

	// Nulls are represented as zeros in the response.
	NullAsZero *NullAsZero `json:"null_as_zero,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesAssetMetricsParamsStatus defines parameters for GetTimeseriesAssetMetrics.
type GetTimeseriesAssetMetricsParamsStatus string

// GetTimeseriesAssetMetricsParamsPagingFrom defines parameters for GetTimeseriesAssetMetrics.
type GetTimeseriesAssetMetricsParamsPagingFrom string

// GetTimeseriesAssetMetricsParamsSort defines parameters for GetTimeseriesAssetMetrics.
type GetTimeseriesAssetMetricsParamsSort string

// GetTimeseriesAssetMetricsParamsFormat defines parameters for GetTimeseriesAssetMetrics.
type GetTimeseriesAssetMetricsParamsFormat string

// GetTimeseriesExchangeAssetMetricsParams defines parameters for GetTimeseriesExchangeAssetMetrics.
type GetTimeseriesExchangeAssetMetricsParams struct {
	// List of exchange-asset pairs.
	ExchangeAssets ExchangeAssets `json:"exchange_assets"`

	// Comma separated metrics to request time series data for.<br/> Information on all available metrics can be found on page https://docs.coinmetrics.io/info/pair_metrics.<br/> Use the [/catalog-all/exchange-assets](#operation/getCatalogAllExchangeAssets) endpoint for the full list of supported metrics per exchange-asset combination.
	Metrics ExchangeAssetMetricsParam `json:"metrics"`

	// Frequency of the exchange-asset metrics. Supported values are `5m`, `1h`, `1d`.
	Frequency *ExchangeAssetMetricsFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesExchangeAssetMetricsParamsPagingFrom `json:"paging_from,omitempty"`

	// How results will be sorted. Metrics are sorted by `(exchange_asset, time)` by default. If you want to sort `1d` metrics by `(time, exchange_asset)` you should choose `time` as value for the `sort` parameter.<br/> Sorting by `time` is useful if you request metrics for a set of exchange-assets.
	Sort *GetTimeseriesExchangeAssetMetricsParamsSort `json:"sort,omitempty"`

	// How many entries per exchange_asset result should contain. For example, this combination of parameters `exchange_assets=binance-btc,coinbase-eth&metrics=volume_trusted_spot_usd_1h&limit_per_exchange_asset=1` returns the latest `volume_trusted_spot_usd_1h` values for `binance-btc` and `coinbase-eth`.
	LimitPerExchangeAsset *LimitPerExchangeAsset `json:"limit_per_exchange_asset,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Format of the response.
	Format *GetTimeseriesExchangeAssetMetricsParamsFormat `json:"format,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesExchangeAssetMetricsParamsPagingFrom defines parameters for GetTimeseriesExchangeAssetMetrics.
type GetTimeseriesExchangeAssetMetricsParamsPagingFrom string

// GetTimeseriesExchangeAssetMetricsParamsSort defines parameters for GetTimeseriesExchangeAssetMetrics.
type GetTimeseriesExchangeAssetMetricsParamsSort string

// GetTimeseriesExchangeAssetMetricsParamsFormat defines parameters for GetTimeseriesExchangeAssetMetrics.
type GetTimeseriesExchangeAssetMetricsParamsFormat string

// GetTimeseriesExchangeMetricsParams defines parameters for GetTimeseriesExchangeMetrics.
type GetTimeseriesExchangeMetricsParams struct {
	// List of exchanges names.
	Exchanges Exchanges `json:"exchanges"`

	// Comma separated metrics to request time series data for.<br/> Information on all available metrics can be found on page https://docs.coinmetrics.io/info/pair_metrics.<br/> Use the [/catalog-all/exchange](#operation/getCatalogAllExchanges) endpoint for the full list of supported metrics per exchange.
	Metrics ExchangeMetricsParam `json:"metrics"`

	// Frequency of the exchange metrics. Supported values are `1h`, `1d`.
	Frequency *ExchangeMetricsFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesExchangeMetricsParamsPagingFrom `json:"paging_from,omitempty"`

	// How results will be sorted. Metrics are sorted by `(exchange, time)` by default. If you want to sort `1d` metrics by `(time, exchange)` you should choose `time` as value for the `sort` parameter.<br/> Sorting by `time` is useful if you request metrics for a set of exchanges.
	Sort *GetTimeseriesExchangeMetricsParamsSort `json:"sort,omitempty"`

	// How many entries per institution result should contain. For example, this combination of parameters `exchanges=binance,coinbase&metrics=volume_trusted_spot_usd_1h&limit_per_exchange=1` returns the latest `volume_trusted_spot_usd_1h` values for `binance` and `coinbase`.
	LimitPerExchange *LimitPerExchange `json:"limit_per_exchange,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Format of the response.
	Format *GetTimeseriesExchangeMetricsParamsFormat `json:"format,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesExchangeMetricsParamsPagingFrom defines parameters for GetTimeseriesExchangeMetrics.
type GetTimeseriesExchangeMetricsParamsPagingFrom string

// GetTimeseriesExchangeMetricsParamsSort defines parameters for GetTimeseriesExchangeMetrics.
type GetTimeseriesExchangeMetricsParamsSort string

// GetTimeseriesExchangeMetricsParamsFormat defines parameters for GetTimeseriesExchangeMetrics.
type GetTimeseriesExchangeMetricsParamsFormat string

// GetTimeseriesIndexConstituentsParams defines parameters for GetTimeseriesIndexConstituents.
type GetTimeseriesIndexConstituentsParams struct {
	// Comma separated list of indexes.<br/> Use the [/catalog-all/indexes](#operation/getCatalogAllIndexes) endpoint for the full list of supported indexes.
	Indexes IndexId `json:"indexes"`

	// Frequency of index constituents. Supported values are `1h`, `1d`, `1d-ny-close`, `1d-ny-midday`, `1d-sg-close`.<br/> If omitted, only changed constituents are returned.
	Frequency *IndexConstituentsFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesIndexConstituentsParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesIndexConstituentsParamsPagingFrom defines parameters for GetTimeseriesIndexConstituents.
type GetTimeseriesIndexConstituentsParamsPagingFrom string

// GetTimeseriesIndexLevelsParams defines parameters for GetTimeseriesIndexLevels.
type GetTimeseriesIndexLevelsParams struct {
	// Comma separated list of indexes.<br/> Use the [/catalog-all/indexes](#operation/getCatalogAllIndexes) endpoint for the full list of supported indexes.
	Indexes IndexId `json:"indexes"`

	// Frequency of the index. Supported values are `15s`, `1h`, `1d-ny-close`, `1d-sg-close`, `1d`.<br/> Use the [/catalog-all/indexes](#operation/getCatalogAllIndexes) endpoint for the full list of supported frequencies per index.
	Frequency *IndexFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesIndexLevelsParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per index result should contain. It is useful when multiple indexes are requested.
	LimitPerIndex *LimitPerIndex `json:"limit_per_index,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesIndexLevelsParamsPagingFrom defines parameters for GetTimeseriesIndexLevels.
type GetTimeseriesIndexLevelsParamsPagingFrom string

// GetTimeseriesInstitutionMetricsParams defines parameters for GetTimeseriesInstitutionMetrics.
type GetTimeseriesInstitutionMetricsParams struct {
	// Comma separated list of institutions.<br/> Use the [/catalog-all/institutions](#operation/getCatalogAllInstitutions) endpoint for the full list of supported institutions.
	Institutions Institution `json:"institutions"`

	// Comma separated metrics to request time series data for.<br/> Information on all available metrics can be found on page https://docs.coinmetrics.io/info/institution_metrics.<br/> Use the [/catalog-all/institutions](#operation/getCatalogAllInstitutions) endpoint for the full list of supported metrics per institution.
	Metrics InstitutionMetricsParam `json:"metrics"`

	// Frequency of the institution metrics. Supported values are `1d`.
	Frequency *InstitutionMetricsFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesInstitutionMetricsParamsPagingFrom `json:"paging_from,omitempty"`

	// How results will be sorted. Metrics are sorted by `(institution, time)` by default. If you want to sort `1d` metrics by `(time, institution)` you should choose `time` as value for the `sort` parameter.<br/> Sorting by `time` is useful if you request metrics for a set of institutions.
	Sort *GetTimeseriesInstitutionMetricsParamsSort `json:"sort,omitempty"`

	// How many entries per institution result should contain. For example, this combination of parameters `institutions=institution1,institution2&metrics=total_assets&limit_per_institution=1` returns the latest `total_assets` values for `institution1` and `institution2`.
	LimitPerInstitution *LimitPerInstitution `json:"limit_per_institution,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Format of the response.
	Format *GetTimeseriesInstitutionMetricsParamsFormat `json:"format,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesInstitutionMetricsParamsPagingFrom defines parameters for GetTimeseriesInstitutionMetrics.
type GetTimeseriesInstitutionMetricsParamsPagingFrom string

// GetTimeseriesInstitutionMetricsParamsSort defines parameters for GetTimeseriesInstitutionMetrics.
type GetTimeseriesInstitutionMetricsParamsSort string

// GetTimeseriesInstitutionMetricsParamsFormat defines parameters for GetTimeseriesInstitutionMetrics.
type GetTimeseriesInstitutionMetricsParamsFormat string

// GetTimeseriesMarketCandlesParams defines parameters for GetTimeseriesMarketCandles.
type GetTimeseriesMarketCandlesParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Candle duration. Supported values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`.
	Frequency *CandleFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketCandlesParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketCandlesParamsPagingFrom defines parameters for GetTimeseriesMarketCandles.
type GetTimeseriesMarketCandlesParamsPagingFrom string

// GetTimeseriesMarketContractPricesParams defines parameters for GetTimeseriesMarketContractPrices.
type GetTimeseriesMarketContractPricesParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketContractPricesParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketContractPricesParamsPagingFrom defines parameters for GetTimeseriesMarketContractPrices.
type GetTimeseriesMarketContractPricesParamsPagingFrom string

// GetTimeseriesMarketFundingRatesParams defines parameters for GetTimeseriesMarketFundingRates.
type GetTimeseriesMarketFundingRatesParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketFundingRatesParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketFundingRatesParamsPagingFrom defines parameters for GetTimeseriesMarketFundingRates.
type GetTimeseriesMarketFundingRatesParamsPagingFrom string

// GetTimeseriesMarketGreeksParams defines parameters for GetTimeseriesMarketGreeks.
type GetTimeseriesMarketGreeksParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketGreeksParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketGreeksParamsPagingFrom defines parameters for GetTimeseriesMarketGreeks.
type GetTimeseriesMarketGreeksParamsPagingFrom string

// GetTimeseriesMarketImpliedVolatilityParams defines parameters for GetTimeseriesMarketImpliedVolatility.
type GetTimeseriesMarketImpliedVolatilityParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketImpliedVolatilityParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketImpliedVolatilityParamsPagingFrom defines parameters for GetTimeseriesMarketImpliedVolatility.
type GetTimeseriesMarketImpliedVolatilityParamsPagingFrom string

// GetTimeseriesMarketLiquidationsParams defines parameters for GetTimeseriesMarketLiquidations.
type GetTimeseriesMarketLiquidationsParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketLiquidationsParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketLiquidationsParamsPagingFrom defines parameters for GetTimeseriesMarketLiquidations.
type GetTimeseriesMarketLiquidationsParamsPagingFrom string

// GetTimeseriesMarketMetricsParams defines parameters for GetTimeseriesMarketMetrics.
type GetTimeseriesMarketMetricsParams struct {
	// List of markets.
	Markets Markets `json:"markets"`

	// Comma separated metrics to request time series data for.<br/> Use the [/catalog-all/market-metrics](#operation/getCatalogAllMarketMetrics) endpoint for the full list of supported metrics per exchange-asset combination.
	Metrics MarketMetricsParam `json:"metrics"`

	// Frequency of the market metrics. Supported values are `5m`, `1h`, `1d`.
	Frequency *MarketMetricsFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketMetricsParamsPagingFrom `json:"paging_from,omitempty"`

	// How results will be sorted. Metrics are sorted by `(market, time)` by default. If you want to sort `1d` metrics by `(time, market)` you should choose `time` as value for the `sort` parameter.<br/> Sorting by `time` is useful if you request metrics for a set of markets.
	Sort *GetTimeseriesMarketMetricsParamsSort `json:"sort,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Format of the response.
	Format *GetTimeseriesMarketMetricsParamsFormat `json:"format,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketMetricsParamsPagingFrom defines parameters for GetTimeseriesMarketMetrics.
type GetTimeseriesMarketMetricsParamsPagingFrom string

// GetTimeseriesMarketMetricsParamsSort defines parameters for GetTimeseriesMarketMetrics.
type GetTimeseriesMarketMetricsParamsSort string

// GetTimeseriesMarketMetricsParamsFormat defines parameters for GetTimeseriesMarketMetrics.
type GetTimeseriesMarketMetricsParamsFormat string

// GetTimeseriesMarketOpenInteresetParams defines parameters for GetTimeseriesMarketOpenIntereset.
type GetTimeseriesMarketOpenInteresetParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketOpenInteresetParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketOpenInteresetParamsPagingFrom defines parameters for GetTimeseriesMarketOpenIntereset.
type GetTimeseriesMarketOpenInteresetParamsPagingFrom string

// GetTimeseriesMarketOrderbooksParams defines parameters for GetTimeseriesMarketOrderbooks.
type GetTimeseriesMarketOrderbooksParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Book depth limit. Supported values are 1-30000 or `full_book`.
	DepthLimit *BookDepth `json:"depth_limit,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketOrderbooksParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketOrderbooksParamsPagingFrom defines parameters for GetTimeseriesMarketOrderbooks.
type GetTimeseriesMarketOrderbooksParamsPagingFrom string

// GetTimeseriesMarketQuotesParams defines parameters for GetTimeseriesMarketQuotes.
type GetTimeseriesMarketQuotesParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketQuotesParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMarketQuotesParamsPagingFrom defines parameters for GetTimeseriesMarketQuotes.
type GetTimeseriesMarketQuotesParamsPagingFrom string

// GetTimeseriesMarketTradesParams defines parameters for GetTimeseriesMarketTrades.
type GetTimeseriesMarketTradesParams struct {
	// Comma separated list of markets or market patterns like `exchange-*` or `exchange-*-spot` or `*USDT-future`.<br/> Use the [/catalog-all/markets](#operation/getCatalogAllMarkets) endpoint for the full list of supported markets.
	Markets MarketId `json:"markets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMarketTradesParamsPagingFrom `json:"paging_from,omitempty"`

	// How many entries per market result should contain. It is useful when multiple markets are requested.
	LimitPerMarket *LimitPerMarket `json:"limit_per_market,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`

	// Specifies how many blocks behind the chain tip trades are based on. Default is `2`. For example, a `min_confirmations` of `0` means trades are being collected for all blocks up to the block at the tip of the chain (the latest block received by our node) whereas a `min_confirmations` of `6` means that trades are being collected for all blocks up to the block that is `6` blocks behind the chain tip (i.e., the 7th block if the chain tip is block 1). Currently available only for DeFi markets.
	MinConfirmations *TradeMinConfirmations `json:"min_confirmations,omitempty"`
}

// GetTimeseriesMarketTradesParamsPagingFrom defines parameters for GetTimeseriesMarketTrades.
type GetTimeseriesMarketTradesParamsPagingFrom string

// GetMempoolFeeratesParams defines parameters for GetMempoolFeerates.
type GetMempoolFeeratesParams struct {
	// Comma separated list of assets.<br/> Use the [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported assets.
	Assets AssetId `json:"assets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of mempool feerate snapshots per single page of results.
	PageSize *MempoolFeeratesPageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetMempoolFeeratesParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetMempoolFeeratesParamsPagingFrom defines parameters for GetMempoolFeerates.
type GetMempoolFeeratesParamsPagingFrom string

// GetTimeseriesMiningPoolTipsSummaryParams defines parameters for GetTimeseriesMiningPoolTipsSummary.
type GetTimeseriesMiningPoolTipsSummaryParams struct {
	// Comma separated list of assets.<br/> Use the [/catalog-all/assets](#operation/getCatalogAllAssets) endpoint for the full list of supported assets.
	Assets AssetId `json:"assets"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesMiningPoolTipsSummaryParamsPagingFrom `json:"paging_from,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesMiningPoolTipsSummaryParamsPagingFrom defines parameters for GetTimeseriesMiningPoolTipsSummary.
type GetTimeseriesMiningPoolTipsSummaryParamsPagingFrom string

// GetTimeseriesPairMetricsParams defines parameters for GetTimeseriesPairMetrics.
type GetTimeseriesPairMetricsParams struct {
	// Comma separated list of asset pairs.<br/> Use the [/catalog-all/pairs](#operation/getCatalogAllAssetPairs) endpoint for the full list of supported asset pairs.
	Pairs Pair `json:"pairs"`

	// Comma separated metrics to request time series data for.<br/> Information on all available metrics can be found on page https://docs.coinmetrics.io/info/pair_metrics.<br/> Use the [/catalog-all/pairs](#operation/getCatalogAllAssetPairs) endpoint for the full list of supported metrics per pair.
	Metrics PairMetricsParam `json:"metrics"`

	// Frequency of the pair metrics. Supported values are `1h`, `1d`.
	Frequency *PairMetricsFrequency `json:"frequency,omitempty"`

	// Start of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `start_height` and `start_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `start_time` is omitted, response will include time series from the **earliest** time available.
	StartTime *StartTime `json:"start_time,omitempty"`

	// End of the time interval.<br/> Multiple formats of ISO 8601 are supported: `2006-01-20T00:00:00Z`, `2006-01-20T00:00:00.000Z`, `2006-01-20T00:00:00.123456Z`, `2006-01-20T00:00:00.123456789Z`, `2006-01-20`, `20060120`.<br/> Inclusive by default. Mutually exclusive with `end_height` and `end_hash`.<br/> UTC timezone by default. `Z` suffix is optional and `timezone` parameter has a priority over it.<br/> If `end_time` is omitted, response will include time series up to the **latest** time available.
	EndTime *EndTime `json:"end_time,omitempty"`

	// Inclusive or exclusive corresponding `start_*` parameters.
	StartInclusive *StartInclusive `json:"start_inclusive,omitempty"`

	// Inclusive or exclusive corresponding `end_*` parameters.
	EndInclusive *EndInclusive `json:"end_inclusive,omitempty"`

	// Timezone name for `start_time` and `end_time` timestamps.<br/> This parameter does not modify the output times, which are always `UTC`.<br/> Format is defined by [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *Timezone `json:"timezone,omitempty"`

	// Number of items per single page of results.
	PageSize *PageSize `json:"page_size,omitempty"`

	// Where does the first page start, at the start of the interval or at the end.
	PagingFrom *GetTimeseriesPairMetricsParamsPagingFrom `json:"paging_from,omitempty"`

	// How results will be sorted. Metrics are sorted by `(pair, time)` by default. If you want to sort `1d` metrics by `(time, pair)` you should choose `time` as value for the `sort` parameter.<br/> Sorting by `time` is useful if you request metrics for a set of asset pairs.
	Sort *GetTimeseriesPairMetricsParamsSort `json:"sort,omitempty"`

	// How many entries per pair result should contain. For example, this combination of parameters `pair=btc-usd,eth-usd&metrics=volume_trusted_spot_usd_1h&limit_per_pair=1` returns the latest `volume_trusted_spot_usd_1h` values for `btc-usd` and `eth-usd`.
	LimitPerPair *LimitPerPair `json:"limit_per_pair,omitempty"`

	// Human-readable formatting of JSON responses.
	Pretty *Pretty `json:"pretty,omitempty"`

	// Format of the response.
	Format *GetTimeseriesPairMetricsParamsFormat `json:"format,omitempty"`

	// Token for receiving the results from the next page of a query.<br/> Should not be used directly. To iterate through pages just use `next_page_url` response field.
	NextPageToken *NextPageToken `json:"next_page_token,omitempty"`
}

// GetTimeseriesPairMetricsParamsPagingFrom defines parameters for GetTimeseriesPairMetrics.
type GetTimeseriesPairMetricsParamsPagingFrom string

// GetTimeseriesPairMetricsParamsSort defines parameters for GetTimeseriesPairMetrics.
type GetTimeseriesPairMetricsParamsSort string

// GetTimeseriesPairMetricsParamsFormat defines parameters for GetTimeseriesPairMetrics.
type GetTimeseriesPairMetricsParamsFormat string

// Getter for additional properties for StreamingAssetMetric. Returns the specified
// element and whether it was found
func (a StreamingAssetMetric) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StreamingAssetMetric
func (a *StreamingAssetMetric) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StreamingAssetMetric to handle AdditionalProperties
func (a *StreamingAssetMetric) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["asset"]; found {
		err = json.Unmarshal(raw, &a.Asset)
		if err != nil {
			return fmt.Errorf("error reading 'asset': %w", err)
		}
		delete(object, "asset")
	}

	if raw, found := object["cm_sequence_id"]; found {
		err = json.Unmarshal(raw, &a.CmSequenceId)
		if err != nil {
			return fmt.Errorf("error reading 'cm_sequence_id': %w", err)
		}
		delete(object, "cm_sequence_id")
	}

	if raw, found := object["time"]; found {
		err = json.Unmarshal(raw, &a.Time)
		if err != nil {
			return fmt.Errorf("error reading 'time': %w", err)
		}
		delete(object, "time")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StreamingAssetMetric to handle AdditionalProperties
func (a StreamingAssetMetric) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["asset"], err = json.Marshal(a.Asset)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'asset': %w", err)
	}

	object["cm_sequence_id"], err = json.Marshal(a.CmSequenceId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'cm_sequence_id': %w", err)
	}

	object["time"], err = json.Marshal(a.Time)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'time': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBlockchainV2ListOfAccounts request
	GetBlockchainV2ListOfAccounts(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainV2ListOfBalanceUpdates request
	GetBlockchainV2ListOfBalanceUpdates(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainV2ListOfBlocks request
	GetBlockchainV2ListOfBlocks(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBlocksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainV2FullBlock request
	GetBlockchainV2FullBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainV2FullBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainV2FullTransactionForBlock request
	GetBlockchainV2FullTransactionForBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainV2ListOfSubAccounts request
	GetBlockchainV2ListOfSubAccounts(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfSubAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainV2ListOfTransactions request
	GetBlockchainV2ListOfTransactions(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainV2FullTransaction request
	GetBlockchainV2FullTransaction(ctx context.Context, asset BlockchainAsset, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainListOfAccounts request
	GetBlockchainListOfAccounts(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainListOfBalanceUpdates request
	GetBlockchainListOfBalanceUpdates(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainListOfBlocks request
	GetBlockchainListOfBlocks(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBlocksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainFullBlock request
	GetBlockchainFullBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainFullBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainFullTransactionForBlock request
	GetBlockchainFullTransactionForBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionTracker request
	GetTransactionTracker(ctx context.Context, asset BlockchainAsset, params *GetTransactionTrackerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainListOfTransactions request
	GetBlockchainListOfTransactions(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockchainFullTransaction request
	GetBlockchainFullTransaction(ctx context.Context, asset BlockchainAsset, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllAssetAlertRules request
	GetCatalogAllAssetAlertRules(ctx context.Context, params *GetCatalogAllAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllAssets request
	GetCatalogAllAssets(ctx context.Context, params *GetCatalogAllAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllExchangeAssets request
	GetCatalogAllExchangeAssets(ctx context.Context, params *GetCatalogAllExchangeAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllExchanges request
	GetCatalogAllExchanges(ctx context.Context, params *GetCatalogAllExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllIndexes request
	GetCatalogAllIndexes(ctx context.Context, params *GetCatalogAllIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllInstitutions request
	GetCatalogAllInstitutions(ctx context.Context, params *GetCatalogAllInstitutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllMarketCandles request
	GetCatalogAllMarketCandles(ctx context.Context, params *GetCatalogAllMarketCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllMarketMetrics request
	GetCatalogAllMarketMetrics(ctx context.Context, params *GetCatalogAllMarketMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllMarkets request
	GetCatalogAllMarkets(ctx context.Context, params *GetCatalogAllMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllMetrics request
	GetCatalogAllMetrics(ctx context.Context, params *GetCatalogAllMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAllAssetPairs request
	GetCatalogAllAssetPairs(ctx context.Context, params *GetCatalogAllAssetPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAssetAlertRules request
	GetCatalogAssetAlertRules(ctx context.Context, params *GetCatalogAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAssets request
	GetCatalogAssets(ctx context.Context, params *GetCatalogAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogExchangeAssets request
	GetCatalogExchangeAssets(ctx context.Context, params *GetCatalogExchangeAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogExchanges request
	GetCatalogExchanges(ctx context.Context, params *GetCatalogExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogIndexes request
	GetCatalogIndexes(ctx context.Context, params *GetCatalogIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogInstitutions request
	GetCatalogInstitutions(ctx context.Context, params *GetCatalogInstitutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogMarketCandles request
	GetCatalogMarketCandles(ctx context.Context, params *GetCatalogMarketCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogMarketMetrics request
	GetCatalogMarketMetrics(ctx context.Context, params *GetCatalogMarketMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogMarkets request
	GetCatalogMarkets(ctx context.Context, params *GetCatalogMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogMetrics request
	GetCatalogMetrics(ctx context.Context, params *GetCatalogMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogAssetPairs request
	GetCatalogAssetPairs(ctx context.Context, params *GetCatalogAssetPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesStreamAssetMetrics request
	GetTimeseriesStreamAssetMetrics(ctx context.Context, params *GetTimeseriesStreamAssetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesStreamMarketOrderbooks request
	GetTimeseriesStreamMarketOrderbooks(ctx context.Context, params *GetTimeseriesStreamMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesStreamMarketQuotes request
	GetTimeseriesStreamMarketQuotes(ctx context.Context, params *GetTimeseriesStreamMarketQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesStreamMarketTrades request
	GetTimeseriesStreamMarketTrades(ctx context.Context, params *GetTimeseriesStreamMarketTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetAlerts request
	GetAssetAlerts(ctx context.Context, params *GetAssetAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetChains request
	GetAssetChains(ctx context.Context, params *GetAssetChainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesAssetMetrics request
	GetTimeseriesAssetMetrics(ctx context.Context, params *GetTimeseriesAssetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesExchangeAssetMetrics request
	GetTimeseriesExchangeAssetMetrics(ctx context.Context, params *GetTimeseriesExchangeAssetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesExchangeMetrics request
	GetTimeseriesExchangeMetrics(ctx context.Context, params *GetTimeseriesExchangeMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesIndexConstituents request
	GetTimeseriesIndexConstituents(ctx context.Context, params *GetTimeseriesIndexConstituentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesIndexLevels request
	GetTimeseriesIndexLevels(ctx context.Context, params *GetTimeseriesIndexLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesInstitutionMetrics request
	GetTimeseriesInstitutionMetrics(ctx context.Context, params *GetTimeseriesInstitutionMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketCandles request
	GetTimeseriesMarketCandles(ctx context.Context, params *GetTimeseriesMarketCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketContractPrices request
	GetTimeseriesMarketContractPrices(ctx context.Context, params *GetTimeseriesMarketContractPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketFundingRates request
	GetTimeseriesMarketFundingRates(ctx context.Context, params *GetTimeseriesMarketFundingRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketGreeks request
	GetTimeseriesMarketGreeks(ctx context.Context, params *GetTimeseriesMarketGreeksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketImpliedVolatility request
	GetTimeseriesMarketImpliedVolatility(ctx context.Context, params *GetTimeseriesMarketImpliedVolatilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketLiquidations request
	GetTimeseriesMarketLiquidations(ctx context.Context, params *GetTimeseriesMarketLiquidationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketMetrics request
	GetTimeseriesMarketMetrics(ctx context.Context, params *GetTimeseriesMarketMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketOpenIntereset request
	GetTimeseriesMarketOpenIntereset(ctx context.Context, params *GetTimeseriesMarketOpenInteresetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketOrderbooks request
	GetTimeseriesMarketOrderbooks(ctx context.Context, params *GetTimeseriesMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketQuotes request
	GetTimeseriesMarketQuotes(ctx context.Context, params *GetTimeseriesMarketQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMarketTrades request
	GetTimeseriesMarketTrades(ctx context.Context, params *GetTimeseriesMarketTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMempoolFeerates request
	GetMempoolFeerates(ctx context.Context, params *GetMempoolFeeratesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesMiningPoolTipsSummary request
	GetTimeseriesMiningPoolTipsSummary(ctx context.Context, params *GetTimeseriesMiningPoolTipsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeseriesPairMetrics request
	GetTimeseriesPairMetrics(ctx context.Context, params *GetTimeseriesPairMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBlockchainV2ListOfAccounts(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2ListOfAccountsRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainV2ListOfBalanceUpdates(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2ListOfBalanceUpdatesRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainV2ListOfBlocks(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBlocksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2ListOfBlocksRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainV2FullBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainV2FullBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2FullBlockRequest(c.Server, asset, blockHash, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainV2FullTransactionForBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2FullTransactionForBlockRequest(c.Server, asset, blockHash, txid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainV2ListOfSubAccounts(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfSubAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2ListOfSubAccountsRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainV2ListOfTransactions(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2ListOfTransactionsRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainV2FullTransaction(ctx context.Context, asset BlockchainAsset, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainV2FullTransactionRequest(c.Server, asset, txid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainListOfAccounts(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainListOfAccountsRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainListOfBalanceUpdates(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainListOfBalanceUpdatesRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainListOfBlocks(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBlocksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainListOfBlocksRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainFullBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainFullBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainFullBlockRequest(c.Server, asset, blockHash, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainFullTransactionForBlock(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainFullTransactionForBlockRequest(c.Server, asset, blockHash, transactionHash, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionTracker(ctx context.Context, asset BlockchainAsset, params *GetTransactionTrackerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionTrackerRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainListOfTransactions(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainListOfTransactionsRequest(c.Server, asset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockchainFullTransaction(ctx context.Context, asset BlockchainAsset, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockchainFullTransactionRequest(c.Server, asset, transactionHash, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllAssetAlertRules(ctx context.Context, params *GetCatalogAllAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllAssetAlertRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllAssets(ctx context.Context, params *GetCatalogAllAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllExchangeAssets(ctx context.Context, params *GetCatalogAllExchangeAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllExchangeAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllExchanges(ctx context.Context, params *GetCatalogAllExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllIndexes(ctx context.Context, params *GetCatalogAllIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllIndexesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllInstitutions(ctx context.Context, params *GetCatalogAllInstitutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllInstitutionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllMarketCandles(ctx context.Context, params *GetCatalogAllMarketCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllMarketCandlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllMarketMetrics(ctx context.Context, params *GetCatalogAllMarketMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllMarketMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllMarkets(ctx context.Context, params *GetCatalogAllMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllMarketsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllMetrics(ctx context.Context, params *GetCatalogAllMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAllAssetPairs(ctx context.Context, params *GetCatalogAllAssetPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAllAssetPairsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAssetAlertRules(ctx context.Context, params *GetCatalogAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAssetAlertRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAssets(ctx context.Context, params *GetCatalogAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogExchangeAssets(ctx context.Context, params *GetCatalogExchangeAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogExchangeAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogExchanges(ctx context.Context, params *GetCatalogExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogIndexes(ctx context.Context, params *GetCatalogIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogIndexesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogInstitutions(ctx context.Context, params *GetCatalogInstitutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogInstitutionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogMarketCandles(ctx context.Context, params *GetCatalogMarketCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogMarketCandlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogMarketMetrics(ctx context.Context, params *GetCatalogMarketMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogMarketMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogMarkets(ctx context.Context, params *GetCatalogMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogMarketsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogMetrics(ctx context.Context, params *GetCatalogMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogAssetPairs(ctx context.Context, params *GetCatalogAssetPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogAssetPairsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesStreamAssetMetrics(ctx context.Context, params *GetTimeseriesStreamAssetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesStreamAssetMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesStreamMarketOrderbooks(ctx context.Context, params *GetTimeseriesStreamMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesStreamMarketOrderbooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesStreamMarketQuotes(ctx context.Context, params *GetTimeseriesStreamMarketQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesStreamMarketQuotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesStreamMarketTrades(ctx context.Context, params *GetTimeseriesStreamMarketTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesStreamMarketTradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetAlerts(ctx context.Context, params *GetAssetAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetAlertsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetChains(ctx context.Context, params *GetAssetChainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetChainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesAssetMetrics(ctx context.Context, params *GetTimeseriesAssetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesAssetMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesExchangeAssetMetrics(ctx context.Context, params *GetTimeseriesExchangeAssetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesExchangeAssetMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesExchangeMetrics(ctx context.Context, params *GetTimeseriesExchangeMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesExchangeMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesIndexConstituents(ctx context.Context, params *GetTimeseriesIndexConstituentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesIndexConstituentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesIndexLevels(ctx context.Context, params *GetTimeseriesIndexLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesIndexLevelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesInstitutionMetrics(ctx context.Context, params *GetTimeseriesInstitutionMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesInstitutionMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketCandles(ctx context.Context, params *GetTimeseriesMarketCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketCandlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketContractPrices(ctx context.Context, params *GetTimeseriesMarketContractPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketContractPricesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketFundingRates(ctx context.Context, params *GetTimeseriesMarketFundingRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketFundingRatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketGreeks(ctx context.Context, params *GetTimeseriesMarketGreeksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketGreeksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketImpliedVolatility(ctx context.Context, params *GetTimeseriesMarketImpliedVolatilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketImpliedVolatilityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketLiquidations(ctx context.Context, params *GetTimeseriesMarketLiquidationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketLiquidationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketMetrics(ctx context.Context, params *GetTimeseriesMarketMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketOpenIntereset(ctx context.Context, params *GetTimeseriesMarketOpenInteresetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketOpenInteresetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketOrderbooks(ctx context.Context, params *GetTimeseriesMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketOrderbooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketQuotes(ctx context.Context, params *GetTimeseriesMarketQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketQuotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMarketTrades(ctx context.Context, params *GetTimeseriesMarketTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMarketTradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMempoolFeerates(ctx context.Context, params *GetMempoolFeeratesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMempoolFeeratesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesMiningPoolTipsSummary(ctx context.Context, params *GetTimeseriesMiningPoolTipsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesMiningPoolTipsSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeseriesPairMetrics(ctx context.Context, params *GetTimeseriesPairMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeseriesPairMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBlockchainV2ListOfAccountsRequest generates requests for GetBlockchainV2ListOfAccounts
func NewGetBlockchainV2ListOfAccountsRequest(server string, asset BlockchainAsset, params *GetBlockchainV2ListOfAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Accounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_chain_sequence_number", runtime.ParamLocationQuery, *params.StartChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_chain_sequence_number", runtime.ParamLocationQuery, *params.EndChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainV2ListOfBalanceUpdatesRequest generates requests for GetBlockchainV2ListOfBalanceUpdates
func NewGetBlockchainV2ListOfBalanceUpdatesRequest(server string, asset BlockchainAsset, params *GetBlockchainV2ListOfBalanceUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/balance-updates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Accounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubAccounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sub_accounts", runtime.ParamLocationQuery, *params.SubAccounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Txids != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "txids", runtime.ParamLocationQuery, *params.Txids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BlockHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "block_hashes", runtime.ParamLocationQuery, *params.BlockHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_chain_sequence_number", runtime.ParamLocationQuery, *params.StartChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_chain_sequence_number", runtime.ParamLocationQuery, *params.EndChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeSubAccounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sub_accounts", runtime.ParamLocationQuery, *params.IncludeSubAccounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Chain != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, *params.Chain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainV2ListOfBlocksRequest generates requests for GetBlockchainV2ListOfBlocks
func NewGetBlockchainV2ListOfBlocksRequest(server string, asset BlockchainAsset, params *GetBlockchainV2ListOfBlocksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/blocks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BlockHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "block_hashes", runtime.ParamLocationQuery, *params.BlockHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Heights != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "heights", runtime.ParamLocationQuery, *params.Heights); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Chain != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, *params.Chain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainV2FullBlockRequest generates requests for GetBlockchainV2FullBlock
func NewGetBlockchainV2FullBlockRequest(server string, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainV2FullBlockParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "block_hash", runtime.ParamLocationPath, blockHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/blocks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeSubAccounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sub_accounts", runtime.ParamLocationQuery, *params.IncludeSubAccounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainV2FullTransactionForBlockRequest generates requests for GetBlockchainV2FullTransactionForBlock
func NewGetBlockchainV2FullTransactionForBlockRequest(server string, asset BlockchainAsset, blockHash BlockchainBlockHash, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionForBlockParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "block_hash", runtime.ParamLocationPath, blockHash)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "txid", runtime.ParamLocationPath, txid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/blocks/%s/transactions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeSubAccounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sub_accounts", runtime.ParamLocationQuery, *params.IncludeSubAccounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainV2ListOfSubAccountsRequest generates requests for GetBlockchainV2ListOfSubAccounts
func NewGetBlockchainV2ListOfSubAccountsRequest(server string, asset BlockchainAsset, params *GetBlockchainV2ListOfSubAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/sub-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Accounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_chain_sequence_number", runtime.ParamLocationQuery, *params.StartChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_chain_sequence_number", runtime.ParamLocationQuery, *params.EndChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainV2ListOfTransactionsRequest generates requests for GetBlockchainV2ListOfTransactions
func NewGetBlockchainV2ListOfTransactionsRequest(server string, asset BlockchainAsset, params *GetBlockchainV2ListOfTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Txids != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "txids", runtime.ParamLocationQuery, *params.Txids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BlockHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "block_hashes", runtime.ParamLocationQuery, *params.BlockHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Chain != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, *params.Chain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainV2FullTransactionRequest generates requests for GetBlockchainV2FullTransaction
func NewGetBlockchainV2FullTransactionRequest(server string, asset BlockchainAsset, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "txid", runtime.ParamLocationPath, txid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain-v2/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeSubAccounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sub_accounts", runtime.ParamLocationQuery, *params.IncludeSubAccounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainListOfAccountsRequest generates requests for GetBlockchainListOfAccounts
func NewGetBlockchainListOfAccountsRequest(server string, asset BlockchainAsset, params *GetBlockchainListOfAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Accounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_chain_sequence_number", runtime.ParamLocationQuery, *params.StartChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_chain_sequence_number", runtime.ParamLocationQuery, *params.EndChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainListOfBalanceUpdatesRequest generates requests for GetBlockchainListOfBalanceUpdates
func NewGetBlockchainListOfBalanceUpdatesRequest(server string, asset BlockchainAsset, params *GetBlockchainListOfBalanceUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/balance-updates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Accounts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TransactionHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "transaction_hashes", runtime.ParamLocationQuery, *params.TransactionHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BlockHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "block_hashes", runtime.ParamLocationQuery, *params.BlockHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_chain_sequence_number", runtime.ParamLocationQuery, *params.StartChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndChainSequenceNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_chain_sequence_number", runtime.ParamLocationQuery, *params.EndChainSequenceNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainListOfBlocksRequest generates requests for GetBlockchainListOfBlocks
func NewGetBlockchainListOfBlocksRequest(server string, asset BlockchainAsset, params *GetBlockchainListOfBlocksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/blocks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BlockHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "block_hashes", runtime.ParamLocationQuery, *params.BlockHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Heights != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "heights", runtime.ParamLocationQuery, *params.Heights); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainFullBlockRequest generates requests for GetBlockchainFullBlock
func NewGetBlockchainFullBlockRequest(server string, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainFullBlockParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "block_hash", runtime.ParamLocationPath, blockHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/blocks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainFullTransactionForBlockRequest generates requests for GetBlockchainFullTransactionForBlock
func NewGetBlockchainFullTransactionForBlockRequest(server string, asset BlockchainAsset, blockHash BlockchainBlockHash, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionForBlockParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "block_hash", runtime.ParamLocationPath, blockHash)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "transaction_hash", runtime.ParamLocationPath, transactionHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/blocks/%s/transactions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionTrackerRequest generates requests for GetTransactionTracker
func NewGetTransactionTrackerRequest(server string, asset BlockchainAsset, params *GetTransactionTrackerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/transaction-tracker", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Txids != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "txids", runtime.ParamLocationQuery, *params.Txids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReplacementsForTxids != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "replacements_for_txids", runtime.ParamLocationQuery, *params.ReplacementsForTxids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReplacementsOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replacements_only", runtime.ParamLocationQuery, *params.ReplacementsOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainListOfTransactionsRequest generates requests for GetBlockchainListOfTransactions
func NewGetBlockchainListOfTransactionsRequest(server string, asset BlockchainAsset, params *GetBlockchainListOfTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.TransactionHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "transaction_hashes", runtime.ParamLocationQuery, *params.TransactionHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BlockHashes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "block_hashes", runtime.ParamLocationQuery, *params.BlockHashes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockchainFullTransactionRequest generates requests for GetBlockchainFullTransaction
func NewGetBlockchainFullTransactionRequest(server string, asset BlockchainAsset, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset", runtime.ParamLocationPath, asset)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_hash", runtime.ParamLocationPath, transactionHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockchain/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllAssetAlertRulesRequest generates requests for GetCatalogAllAssetAlertRules
func NewGetCatalogAllAssetAlertRulesRequest(server string, params *GetCatalogAllAssetAlertRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Assets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, *params.Assets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Alerts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "alerts", runtime.ParamLocationQuery, *params.Alerts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllAssetsRequest generates requests for GetCatalogAllAssets
func NewGetCatalogAllAssetsRequest(server string, params *GetCatalogAllAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Assets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, *params.Assets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllExchangeAssetsRequest generates requests for GetCatalogAllExchangeAssets
func NewGetCatalogAllExchangeAssetsRequest(server string, params *GetCatalogAllExchangeAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/exchange-assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExchangeAssets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exchange_assets", runtime.ParamLocationQuery, *params.ExchangeAssets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllExchangesRequest generates requests for GetCatalogAllExchanges
func NewGetCatalogAllExchangesRequest(server string, params *GetCatalogAllExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Exchanges != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exchanges", runtime.ParamLocationQuery, *params.Exchanges); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllIndexesRequest generates requests for GetCatalogAllIndexes
func NewGetCatalogAllIndexesRequest(server string, params *GetCatalogAllIndexesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Indexes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "indexes", runtime.ParamLocationQuery, *params.Indexes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllInstitutionsRequest generates requests for GetCatalogAllInstitutions
func NewGetCatalogAllInstitutionsRequest(server string, params *GetCatalogAllInstitutionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/institutions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Institutions != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "institutions", runtime.ParamLocationQuery, *params.Institutions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllMarketCandlesRequest generates requests for GetCatalogAllMarketCandles
func NewGetCatalogAllMarketCandlesRequest(server string, params *GetCatalogAllMarketCandlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/market-candles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Markets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exchange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Base != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quote != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Asset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllMarketMetricsRequest generates requests for GetCatalogAllMarketMetrics
func NewGetCatalogAllMarketMetricsRequest(server string, params *GetCatalogAllMarketMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/market-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Markets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exchange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Base != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quote != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Asset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllMarketsRequest generates requests for GetCatalogAllMarkets
func NewGetCatalogAllMarketsRequest(server string, params *GetCatalogAllMarketsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/markets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Markets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exchange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Base != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quote != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Asset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllMetricsRequest generates requests for GetCatalogAllMetrics
func NewGetCatalogAllMetricsRequest(server string, params *GetCatalogAllMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Metrics != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reviewable != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reviewable", runtime.ParamLocationQuery, *params.Reviewable); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAllAssetPairsRequest generates requests for GetCatalogAllAssetPairs
func NewGetCatalogAllAssetPairsRequest(server string, params *GetCatalogAllAssetPairsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog-all/pairs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pairs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pairs", runtime.ParamLocationQuery, *params.Pairs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAssetAlertRulesRequest generates requests for GetCatalogAssetAlertRules
func NewGetCatalogAssetAlertRulesRequest(server string, params *GetCatalogAssetAlertRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Assets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, *params.Assets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Alerts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "alerts", runtime.ParamLocationQuery, *params.Alerts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAssetsRequest generates requests for GetCatalogAssets
func NewGetCatalogAssetsRequest(server string, params *GetCatalogAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Assets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, *params.Assets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogExchangeAssetsRequest generates requests for GetCatalogExchangeAssets
func NewGetCatalogExchangeAssetsRequest(server string, params *GetCatalogExchangeAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/exchange-assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExchangeAssets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exchange_assets", runtime.ParamLocationQuery, *params.ExchangeAssets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogExchangesRequest generates requests for GetCatalogExchanges
func NewGetCatalogExchangesRequest(server string, params *GetCatalogExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Exchanges != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exchanges", runtime.ParamLocationQuery, *params.Exchanges); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogIndexesRequest generates requests for GetCatalogIndexes
func NewGetCatalogIndexesRequest(server string, params *GetCatalogIndexesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Indexes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "indexes", runtime.ParamLocationQuery, *params.Indexes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogInstitutionsRequest generates requests for GetCatalogInstitutions
func NewGetCatalogInstitutionsRequest(server string, params *GetCatalogInstitutionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/institutions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Institutions != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "institutions", runtime.ParamLocationQuery, *params.Institutions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogMarketCandlesRequest generates requests for GetCatalogMarketCandles
func NewGetCatalogMarketCandlesRequest(server string, params *GetCatalogMarketCandlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/market-candles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Markets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exchange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Base != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quote != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Asset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogMarketMetricsRequest generates requests for GetCatalogMarketMetrics
func NewGetCatalogMarketMetricsRequest(server string, params *GetCatalogMarketMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/market-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Markets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exchange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Base != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quote != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Asset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogMarketsRequest generates requests for GetCatalogMarkets
func NewGetCatalogMarketsRequest(server string, params *GetCatalogMarketsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/markets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Markets != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exchange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Base != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quote != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Asset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogMetricsRequest generates requests for GetCatalogMetrics
func NewGetCatalogMetricsRequest(server string, params *GetCatalogMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Metrics != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reviewable != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reviewable", runtime.ParamLocationQuery, *params.Reviewable); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogAssetPairsRequest generates requests for GetCatalogAssetPairs
func NewGetCatalogAssetPairsRequest(server string, params *GetCatalogAssetPairsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/pairs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pairs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pairs", runtime.ParamLocationQuery, *params.Pairs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesStreamAssetMetricsRequest generates requests for GetTimeseriesStreamAssetMetrics
func NewGetTimeseriesStreamAssetMetricsRequest(server string, params *GetTimeseriesStreamAssetMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries-stream/asset-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, params.Assets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Backfill != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backfill", runtime.ParamLocationQuery, *params.Backfill); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesStreamMarketOrderbooksRequest generates requests for GetTimeseriesStreamMarketOrderbooks
func NewGetTimeseriesStreamMarketOrderbooksRequest(server string, params *GetTimeseriesStreamMarketOrderbooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries-stream/market-orderbooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Backfill != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backfill", runtime.ParamLocationQuery, *params.Backfill); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesStreamMarketQuotesRequest generates requests for GetTimeseriesStreamMarketQuotes
func NewGetTimeseriesStreamMarketQuotesRequest(server string, params *GetTimeseriesStreamMarketQuotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries-stream/market-quotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Backfill != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backfill", runtime.ParamLocationQuery, *params.Backfill); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesStreamMarketTradesRequest generates requests for GetTimeseriesStreamMarketTrades
func NewGetTimeseriesStreamMarketTradesRequest(server string, params *GetTimeseriesStreamMarketTradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries-stream/market-trades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Backfill != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backfill", runtime.ParamLocationQuery, *params.Backfill); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetAlertsRequest generates requests for GetAssetAlerts
func NewGetAssetAlertsRequest(server string, params *GetAssetAlertsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/asset-alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, params.Assets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "alerts", runtime.ParamLocationQuery, params.Alerts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetChainsRequest generates requests for GetAssetChains
func NewGetAssetChainsRequest(server string, params *GetAssetChainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/asset-chains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, params.Assets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesAssetMetricsRequest generates requests for GetTimeseriesAssetMetrics
func NewGetTimeseriesAssetMetricsRequest(server string, params *GetTimeseriesAssetMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/asset-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, params.Assets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_height", runtime.ParamLocationQuery, *params.StartHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHeight != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_height", runtime.ParamLocationQuery, *params.EndHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_hash", runtime.ParamLocationQuery, *params.StartHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_hash", runtime.ParamLocationQuery, *params.EndHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinConfirmations != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_confirmations", runtime.ParamLocationQuery, *params.MinConfirmations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerAsset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_asset", runtime.ParamLocationQuery, *params.LimitPerAsset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NullAsZero != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "null_as_zero", runtime.ParamLocationQuery, *params.NullAsZero); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesExchangeAssetMetricsRequest generates requests for GetTimeseriesExchangeAssetMetrics
func NewGetTimeseriesExchangeAssetMetricsRequest(server string, params *GetTimeseriesExchangeAssetMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/exchange-asset-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exchange_assets", runtime.ParamLocationQuery, params.ExchangeAssets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerExchangeAsset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_exchange_asset", runtime.ParamLocationQuery, *params.LimitPerExchangeAsset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesExchangeMetricsRequest generates requests for GetTimeseriesExchangeMetrics
func NewGetTimeseriesExchangeMetricsRequest(server string, params *GetTimeseriesExchangeMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/exchange-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exchanges", runtime.ParamLocationQuery, params.Exchanges); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerExchange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_exchange", runtime.ParamLocationQuery, *params.LimitPerExchange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesIndexConstituentsRequest generates requests for GetTimeseriesIndexConstituents
func NewGetTimeseriesIndexConstituentsRequest(server string, params *GetTimeseriesIndexConstituentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/index-constituents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "indexes", runtime.ParamLocationQuery, params.Indexes); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesIndexLevelsRequest generates requests for GetTimeseriesIndexLevels
func NewGetTimeseriesIndexLevelsRequest(server string, params *GetTimeseriesIndexLevelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/index-levels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "indexes", runtime.ParamLocationQuery, params.Indexes); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerIndex != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_index", runtime.ParamLocationQuery, *params.LimitPerIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesInstitutionMetricsRequest generates requests for GetTimeseriesInstitutionMetrics
func NewGetTimeseriesInstitutionMetricsRequest(server string, params *GetTimeseriesInstitutionMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/institution-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "institutions", runtime.ParamLocationQuery, params.Institutions); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerInstitution != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_institution", runtime.ParamLocationQuery, *params.LimitPerInstitution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketCandlesRequest generates requests for GetTimeseriesMarketCandles
func NewGetTimeseriesMarketCandlesRequest(server string, params *GetTimeseriesMarketCandlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-candles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()
	

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()
	fmt.Println(queryURL.RawQuery)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketContractPricesRequest generates requests for GetTimeseriesMarketContractPrices
func NewGetTimeseriesMarketContractPricesRequest(server string, params *GetTimeseriesMarketContractPricesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-contract-prices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketFundingRatesRequest generates requests for GetTimeseriesMarketFundingRates
func NewGetTimeseriesMarketFundingRatesRequest(server string, params *GetTimeseriesMarketFundingRatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-funding-rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketGreeksRequest generates requests for GetTimeseriesMarketGreeks
func NewGetTimeseriesMarketGreeksRequest(server string, params *GetTimeseriesMarketGreeksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-greeks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketImpliedVolatilityRequest generates requests for GetTimeseriesMarketImpliedVolatility
func NewGetTimeseriesMarketImpliedVolatilityRequest(server string, params *GetTimeseriesMarketImpliedVolatilityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-implied-volatility")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketLiquidationsRequest generates requests for GetTimeseriesMarketLiquidations
func NewGetTimeseriesMarketLiquidationsRequest(server string, params *GetTimeseriesMarketLiquidationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-liquidations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketMetricsRequest generates requests for GetTimeseriesMarketMetrics
func NewGetTimeseriesMarketMetricsRequest(server string, params *GetTimeseriesMarketMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketOpenInteresetRequest generates requests for GetTimeseriesMarketOpenIntereset
func NewGetTimeseriesMarketOpenInteresetRequest(server string, params *GetTimeseriesMarketOpenInteresetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-openinterest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketOrderbooksRequest generates requests for GetTimeseriesMarketOrderbooks
func NewGetTimeseriesMarketOrderbooksRequest(server string, params *GetTimeseriesMarketOrderbooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-orderbooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepthLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth_limit", runtime.ParamLocationQuery, *params.DepthLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketQuotesRequest generates requests for GetTimeseriesMarketQuotes
func NewGetTimeseriesMarketQuotesRequest(server string, params *GetTimeseriesMarketQuotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-quotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMarketTradesRequest generates requests for GetTimeseriesMarketTrades
func NewGetTimeseriesMarketTradesRequest(server string, params *GetTimeseriesMarketTradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/market-trades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "markets", runtime.ParamLocationQuery, params.Markets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerMarket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_market", runtime.ParamLocationQuery, *params.LimitPerMarket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinConfirmations != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_confirmations", runtime.ParamLocationQuery, *params.MinConfirmations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMempoolFeeratesRequest generates requests for GetMempoolFeerates
func NewGetMempoolFeeratesRequest(server string, params *GetMempoolFeeratesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/mempool-feerates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, params.Assets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesMiningPoolTipsSummaryRequest generates requests for GetTimeseriesMiningPoolTipsSummary
func NewGetTimeseriesMiningPoolTipsSummaryRequest(server string, params *GetTimeseriesMiningPoolTipsSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/mining-pool-tips-summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "assets", runtime.ParamLocationQuery, params.Assets); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeseriesPairMetricsRequest generates requests for GetTimeseriesPairMetrics
func NewGetTimeseriesPairMetricsRequest(server string, params *GetTimeseriesPairMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeseries/pair-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pairs", runtime.ParamLocationQuery, params.Pairs); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Frequency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_inclusive", runtime.ParamLocationQuery, *params.StartInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndInclusive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_inclusive", runtime.ParamLocationQuery, *params.EndInclusive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timezone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PagingFrom != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paging_from", runtime.ParamLocationQuery, *params.PagingFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPerPair != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_per_pair", runtime.ParamLocationQuery, *params.LimitPerPair); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pretty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBlockchainV2ListOfAccounts request
	GetBlockchainV2ListOfAccountsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfAccountsParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfAccountsResponse, error)

	// GetBlockchainV2ListOfBalanceUpdates request
	GetBlockchainV2ListOfBalanceUpdatesWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfBalanceUpdatesResponse, error)

	// GetBlockchainV2ListOfBlocks request
	GetBlockchainV2ListOfBlocksWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBlocksParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfBlocksResponse, error)

	// GetBlockchainV2FullBlock request
	GetBlockchainV2FullBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainV2FullBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2FullBlockResponse, error)

	// GetBlockchainV2FullTransactionForBlock request
	GetBlockchainV2FullTransactionForBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2FullTransactionForBlockResponse, error)

	// GetBlockchainV2ListOfSubAccounts request
	GetBlockchainV2ListOfSubAccountsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfSubAccountsParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfSubAccountsResponse, error)

	// GetBlockchainV2ListOfTransactions request
	GetBlockchainV2ListOfTransactionsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfTransactionsParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfTransactionsResponse, error)

	// GetBlockchainV2FullTransaction request
	GetBlockchainV2FullTransactionWithResponse(ctx context.Context, asset BlockchainAsset, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2FullTransactionResponse, error)

	// GetBlockchainListOfAccounts request
	GetBlockchainListOfAccountsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfAccountsParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfAccountsResponse, error)

	// GetBlockchainListOfBalanceUpdates request
	GetBlockchainListOfBalanceUpdatesWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfBalanceUpdatesResponse, error)

	// GetBlockchainListOfBlocks request
	GetBlockchainListOfBlocksWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBlocksParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfBlocksResponse, error)

	// GetBlockchainFullBlock request
	GetBlockchainFullBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainFullBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainFullBlockResponse, error)

	// GetBlockchainFullTransactionForBlock request
	GetBlockchainFullTransactionForBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainFullTransactionForBlockResponse, error)

	// GetTransactionTracker request
	GetTransactionTrackerWithResponse(ctx context.Context, asset BlockchainAsset, params *GetTransactionTrackerParams, reqEditors ...RequestEditorFn) (*GetTransactionTrackerResponse, error)

	// GetBlockchainListOfTransactions request
	GetBlockchainListOfTransactionsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfTransactionsParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfTransactionsResponse, error)

	// GetBlockchainFullTransaction request
	GetBlockchainFullTransactionWithResponse(ctx context.Context, asset BlockchainAsset, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionParams, reqEditors ...RequestEditorFn) (*GetBlockchainFullTransactionResponse, error)

	// GetCatalogAllAssetAlertRules request
	GetCatalogAllAssetAlertRulesWithResponse(ctx context.Context, params *GetCatalogAllAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllAssetAlertRulesResponse, error)

	// GetCatalogAllAssets request
	GetCatalogAllAssetsWithResponse(ctx context.Context, params *GetCatalogAllAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllAssetsResponse, error)

	// GetCatalogAllExchangeAssets request
	GetCatalogAllExchangeAssetsWithResponse(ctx context.Context, params *GetCatalogAllExchangeAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllExchangeAssetsResponse, error)

	// GetCatalogAllExchanges request
	GetCatalogAllExchangesWithResponse(ctx context.Context, params *GetCatalogAllExchangesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllExchangesResponse, error)

	// GetCatalogAllIndexes request
	GetCatalogAllIndexesWithResponse(ctx context.Context, params *GetCatalogAllIndexesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllIndexesResponse, error)

	// GetCatalogAllInstitutions request
	GetCatalogAllInstitutionsWithResponse(ctx context.Context, params *GetCatalogAllInstitutionsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllInstitutionsResponse, error)

	// GetCatalogAllMarketCandles request
	GetCatalogAllMarketCandlesWithResponse(ctx context.Context, params *GetCatalogAllMarketCandlesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMarketCandlesResponse, error)

	// GetCatalogAllMarketMetrics request
	GetCatalogAllMarketMetricsWithResponse(ctx context.Context, params *GetCatalogAllMarketMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMarketMetricsResponse, error)

	// GetCatalogAllMarkets request
	GetCatalogAllMarketsWithResponse(ctx context.Context, params *GetCatalogAllMarketsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMarketsResponse, error)

	// GetCatalogAllMetrics request
	GetCatalogAllMetricsWithResponse(ctx context.Context, params *GetCatalogAllMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMetricsResponse, error)

	// GetCatalogAllAssetPairs request
	GetCatalogAllAssetPairsWithResponse(ctx context.Context, params *GetCatalogAllAssetPairsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllAssetPairsResponse, error)

	// GetCatalogAssetAlertRules request
	GetCatalogAssetAlertRulesWithResponse(ctx context.Context, params *GetCatalogAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*GetCatalogAssetAlertRulesResponse, error)

	// GetCatalogAssets request
	GetCatalogAssetsWithResponse(ctx context.Context, params *GetCatalogAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogAssetsResponse, error)

	// GetCatalogExchangeAssets request
	GetCatalogExchangeAssetsWithResponse(ctx context.Context, params *GetCatalogExchangeAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogExchangeAssetsResponse, error)

	// GetCatalogExchanges request
	GetCatalogExchangesWithResponse(ctx context.Context, params *GetCatalogExchangesParams, reqEditors ...RequestEditorFn) (*GetCatalogExchangesResponse, error)

	// GetCatalogIndexes request
	GetCatalogIndexesWithResponse(ctx context.Context, params *GetCatalogIndexesParams, reqEditors ...RequestEditorFn) (*GetCatalogIndexesResponse, error)

	// GetCatalogInstitutions request
	GetCatalogInstitutionsWithResponse(ctx context.Context, params *GetCatalogInstitutionsParams, reqEditors ...RequestEditorFn) (*GetCatalogInstitutionsResponse, error)

	// GetCatalogMarketCandles request
	GetCatalogMarketCandlesWithResponse(ctx context.Context, params *GetCatalogMarketCandlesParams, reqEditors ...RequestEditorFn) (*GetCatalogMarketCandlesResponse, error)

	// GetCatalogMarketMetrics request
	GetCatalogMarketMetricsWithResponse(ctx context.Context, params *GetCatalogMarketMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogMarketMetricsResponse, error)

	// GetCatalogMarkets request
	GetCatalogMarketsWithResponse(ctx context.Context, params *GetCatalogMarketsParams, reqEditors ...RequestEditorFn) (*GetCatalogMarketsResponse, error)

	// GetCatalogMetrics request
	GetCatalogMetricsWithResponse(ctx context.Context, params *GetCatalogMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogMetricsResponse, error)

	// GetCatalogAssetPairs request
	GetCatalogAssetPairsWithResponse(ctx context.Context, params *GetCatalogAssetPairsParams, reqEditors ...RequestEditorFn) (*GetCatalogAssetPairsResponse, error)

	// GetTimeseriesStreamAssetMetrics request
	GetTimeseriesStreamAssetMetricsWithResponse(ctx context.Context, params *GetTimeseriesStreamAssetMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamAssetMetricsResponse, error)

	// GetTimeseriesStreamMarketOrderbooks request
	GetTimeseriesStreamMarketOrderbooksWithResponse(ctx context.Context, params *GetTimeseriesStreamMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamMarketOrderbooksResponse, error)

	// GetTimeseriesStreamMarketQuotes request
	GetTimeseriesStreamMarketQuotesWithResponse(ctx context.Context, params *GetTimeseriesStreamMarketQuotesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamMarketQuotesResponse, error)

	// GetTimeseriesStreamMarketTrades request
	GetTimeseriesStreamMarketTradesWithResponse(ctx context.Context, params *GetTimeseriesStreamMarketTradesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamMarketTradesResponse, error)

	// GetAssetAlerts request
	GetAssetAlertsWithResponse(ctx context.Context, params *GetAssetAlertsParams, reqEditors ...RequestEditorFn) (*GetAssetAlertsResponse, error)

	// GetAssetChains request
	GetAssetChainsWithResponse(ctx context.Context, params *GetAssetChainsParams, reqEditors ...RequestEditorFn) (*GetAssetChainsResponse, error)

	// GetTimeseriesAssetMetrics request
	GetTimeseriesAssetMetricsWithResponse(ctx context.Context, params *GetTimeseriesAssetMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesAssetMetricsResponse, error)

	// GetTimeseriesExchangeAssetMetrics request
	GetTimeseriesExchangeAssetMetricsWithResponse(ctx context.Context, params *GetTimeseriesExchangeAssetMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesExchangeAssetMetricsResponse, error)

	// GetTimeseriesExchangeMetrics request
	GetTimeseriesExchangeMetricsWithResponse(ctx context.Context, params *GetTimeseriesExchangeMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesExchangeMetricsResponse, error)

	// GetTimeseriesIndexConstituents request
	GetTimeseriesIndexConstituentsWithResponse(ctx context.Context, params *GetTimeseriesIndexConstituentsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesIndexConstituentsResponse, error)

	// GetTimeseriesIndexLevels request
	GetTimeseriesIndexLevelsWithResponse(ctx context.Context, params *GetTimeseriesIndexLevelsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesIndexLevelsResponse, error)

	// GetTimeseriesInstitutionMetrics request
	GetTimeseriesInstitutionMetricsWithResponse(ctx context.Context, params *GetTimeseriesInstitutionMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesInstitutionMetricsResponse, error)

	// GetTimeseriesMarketCandles request
	GetTimeseriesMarketCandlesWithResponse(ctx context.Context, params *GetTimeseriesMarketCandlesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketCandlesResponse, error)

	// GetTimeseriesMarketContractPrices request
	GetTimeseriesMarketContractPricesWithResponse(ctx context.Context, params *GetTimeseriesMarketContractPricesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketContractPricesResponse, error)

	// GetTimeseriesMarketFundingRates request
	GetTimeseriesMarketFundingRatesWithResponse(ctx context.Context, params *GetTimeseriesMarketFundingRatesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketFundingRatesResponse, error)

	// GetTimeseriesMarketGreeks request
	GetTimeseriesMarketGreeksWithResponse(ctx context.Context, params *GetTimeseriesMarketGreeksParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketGreeksResponse, error)

	// GetTimeseriesMarketImpliedVolatility request
	GetTimeseriesMarketImpliedVolatilityWithResponse(ctx context.Context, params *GetTimeseriesMarketImpliedVolatilityParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketImpliedVolatilityResponse, error)

	// GetTimeseriesMarketLiquidations request
	GetTimeseriesMarketLiquidationsWithResponse(ctx context.Context, params *GetTimeseriesMarketLiquidationsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketLiquidationsResponse, error)

	// GetTimeseriesMarketMetrics request
	GetTimeseriesMarketMetricsWithResponse(ctx context.Context, params *GetTimeseriesMarketMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketMetricsResponse, error)

	// GetTimeseriesMarketOpenIntereset request
	GetTimeseriesMarketOpenInteresetWithResponse(ctx context.Context, params *GetTimeseriesMarketOpenInteresetParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketOpenInteresetResponse, error)

	// GetTimeseriesMarketOrderbooks request
	GetTimeseriesMarketOrderbooksWithResponse(ctx context.Context, params *GetTimeseriesMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketOrderbooksResponse, error)

	// GetTimeseriesMarketQuotes request
	GetTimeseriesMarketQuotesWithResponse(ctx context.Context, params *GetTimeseriesMarketQuotesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketQuotesResponse, error)

	// GetTimeseriesMarketTrades request
	GetTimeseriesMarketTradesWithResponse(ctx context.Context, params *GetTimeseriesMarketTradesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketTradesResponse, error)

	// GetMempoolFeerates request
	GetMempoolFeeratesWithResponse(ctx context.Context, params *GetMempoolFeeratesParams, reqEditors ...RequestEditorFn) (*GetMempoolFeeratesResponse, error)

	// GetTimeseriesMiningPoolTipsSummary request
	GetTimeseriesMiningPoolTipsSummaryWithResponse(ctx context.Context, params *GetTimeseriesMiningPoolTipsSummaryParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMiningPoolTipsSummaryResponse, error)

	// GetTimeseriesPairMetrics request
	GetTimeseriesPairMetricsWithResponse(ctx context.Context, params *GetTimeseriesPairMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesPairMetricsResponse, error)
}

type GetBlockchainV2ListOfAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainAccountsResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2ListOfAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2ListOfAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainV2ListOfBalanceUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainBalanceUpdatesResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2ListOfBalanceUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2ListOfBalanceUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainV2ListOfBlocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainBlocksResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2ListOfBlocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2ListOfBlocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainV2FullBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainFullBlockResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2FullBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2FullBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainV2FullTransactionForBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainFullSingleTransactionResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2FullTransactionForBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2FullTransactionForBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainV2ListOfSubAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainSubAccountsResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2ListOfSubAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2ListOfSubAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainV2ListOfTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainTransactionsResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2ListOfTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2ListOfTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainV2FullTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainFullSingleTransactionResponseV2
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainV2FullTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainV2FullTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainListOfAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainAccountsResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainListOfAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainListOfAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainListOfBalanceUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainBalanceUpdatesResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainListOfBalanceUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainListOfBalanceUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainListOfBlocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainBlocksResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainListOfBlocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainListOfBlocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainFullBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainFullBlockResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainFullBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainFullBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainFullTransactionForBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainFullSingleTransactionResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainFullTransactionForBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainFullTransactionForBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionTrackerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TxTrackerResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionTrackerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionTrackerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainListOfTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainTransactionsResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainListOfTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainListOfTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockchainFullTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockchainFullSingleTransactionResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockchainFullTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockchainFullTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllAssetAlertRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetAlertRulesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllAssetAlertRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllAssetAlertRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllExchangeAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeAssetsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllExchangeAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllExchangeAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllInstitutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstitutionsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllInstitutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllInstitutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllMarketCandlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogMarketCandlesResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllMarketCandlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllMarketCandlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllMarketMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogMarketMetricsResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllMarketMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllMarketMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllMarketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllMarketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllMarketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAllAssetPairsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PairsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAllAssetPairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAllAssetPairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAssetAlertRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetAlertRulesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAssetAlertRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAssetAlertRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogExchangeAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeAssetsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogExchangeAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogExchangeAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogInstitutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstitutionsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogInstitutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogInstitutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogMarketCandlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogMarketCandlesResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogMarketCandlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogMarketCandlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogMarketMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogMarketMetricsResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogMarketMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogMarketMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogMarketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketsResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogMarketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogMarketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogAssetPairsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PairsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCatalogAssetPairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogAssetPairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesStreamAssetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *StreamingAssetMetric
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesStreamAssetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesStreamAssetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesStreamMarketOrderbooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *StreamingMarketOrderbook
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesStreamMarketOrderbooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesStreamMarketOrderbooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesStreamMarketQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *StreamingMarketQuote
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesStreamMarketQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesStreamMarketQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesStreamMarketTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *StreamingMarketTrade
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesStreamMarketTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesStreamMarketTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetAlertsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAssetAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetChainsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAssetChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesAssetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetMetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesAssetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesAssetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesExchangeAssetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeAssetMetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesExchangeAssetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesExchangeAssetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesExchangeMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeMetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesExchangeMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesExchangeMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesIndexConstituentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexConstituentsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesIndexConstituentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesIndexConstituentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesIndexLevelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexLevelsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesIndexLevelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesIndexLevelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesInstitutionMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstitutionMetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesInstitutionMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesInstitutionMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketCandlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketCandlesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketCandlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketCandlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketContractPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketContractPricesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketContractPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketContractPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketFundingRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketFundingRatesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketFundingRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketFundingRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketGreeksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketGreeksResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketGreeksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketGreeksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketImpliedVolatilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketImpliedVolatilityResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketImpliedVolatilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketImpliedVolatilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketLiquidationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketLiquidationsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketLiquidationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketLiquidationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketMetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketOpenInteresetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketOpenInterestResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketOpenInteresetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketOpenInteresetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketOrderbooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketOrderbookResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketOrderbooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketOrderbooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketQuotesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMarketTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketTradesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMarketTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMarketTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMempoolFeeratesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MempoolFeeratesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMempoolFeeratesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMempoolFeeratesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesMiningPoolTipsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MiningPoolTipsSummaryResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesMiningPoolTipsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesMiningPoolTipsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeseriesPairMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PairMetricsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTimeseriesPairMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeseriesPairMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBlockchainV2ListOfAccountsWithResponse request returning *GetBlockchainV2ListOfAccountsResponse
func (c *ClientWithResponses) GetBlockchainV2ListOfAccountsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfAccountsParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfAccountsResponse, error) {
	rsp, err := c.GetBlockchainV2ListOfAccounts(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2ListOfAccountsResponse(rsp)
}

// GetBlockchainV2ListOfBalanceUpdatesWithResponse request returning *GetBlockchainV2ListOfBalanceUpdatesResponse
func (c *ClientWithResponses) GetBlockchainV2ListOfBalanceUpdatesWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfBalanceUpdatesResponse, error) {
	rsp, err := c.GetBlockchainV2ListOfBalanceUpdates(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2ListOfBalanceUpdatesResponse(rsp)
}

// GetBlockchainV2ListOfBlocksWithResponse request returning *GetBlockchainV2ListOfBlocksResponse
func (c *ClientWithResponses) GetBlockchainV2ListOfBlocksWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfBlocksParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfBlocksResponse, error) {
	rsp, err := c.GetBlockchainV2ListOfBlocks(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2ListOfBlocksResponse(rsp)
}

// GetBlockchainV2FullBlockWithResponse request returning *GetBlockchainV2FullBlockResponse
func (c *ClientWithResponses) GetBlockchainV2FullBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainV2FullBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2FullBlockResponse, error) {
	rsp, err := c.GetBlockchainV2FullBlock(ctx, asset, blockHash, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2FullBlockResponse(rsp)
}

// GetBlockchainV2FullTransactionForBlockWithResponse request returning *GetBlockchainV2FullTransactionForBlockResponse
func (c *ClientWithResponses) GetBlockchainV2FullTransactionForBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2FullTransactionForBlockResponse, error) {
	rsp, err := c.GetBlockchainV2FullTransactionForBlock(ctx, asset, blockHash, txid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2FullTransactionForBlockResponse(rsp)
}

// GetBlockchainV2ListOfSubAccountsWithResponse request returning *GetBlockchainV2ListOfSubAccountsResponse
func (c *ClientWithResponses) GetBlockchainV2ListOfSubAccountsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfSubAccountsParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfSubAccountsResponse, error) {
	rsp, err := c.GetBlockchainV2ListOfSubAccounts(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2ListOfSubAccountsResponse(rsp)
}

// GetBlockchainV2ListOfTransactionsWithResponse request returning *GetBlockchainV2ListOfTransactionsResponse
func (c *ClientWithResponses) GetBlockchainV2ListOfTransactionsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainV2ListOfTransactionsParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2ListOfTransactionsResponse, error) {
	rsp, err := c.GetBlockchainV2ListOfTransactions(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2ListOfTransactionsResponse(rsp)
}

// GetBlockchainV2FullTransactionWithResponse request returning *GetBlockchainV2FullTransactionResponse
func (c *ClientWithResponses) GetBlockchainV2FullTransactionWithResponse(ctx context.Context, asset BlockchainAsset, txid BlockchainTransactionId, params *GetBlockchainV2FullTransactionParams, reqEditors ...RequestEditorFn) (*GetBlockchainV2FullTransactionResponse, error) {
	rsp, err := c.GetBlockchainV2FullTransaction(ctx, asset, txid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainV2FullTransactionResponse(rsp)
}

// GetBlockchainListOfAccountsWithResponse request returning *GetBlockchainListOfAccountsResponse
func (c *ClientWithResponses) GetBlockchainListOfAccountsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfAccountsParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfAccountsResponse, error) {
	rsp, err := c.GetBlockchainListOfAccounts(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainListOfAccountsResponse(rsp)
}

// GetBlockchainListOfBalanceUpdatesWithResponse request returning *GetBlockchainListOfBalanceUpdatesResponse
func (c *ClientWithResponses) GetBlockchainListOfBalanceUpdatesWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfBalanceUpdatesResponse, error) {
	rsp, err := c.GetBlockchainListOfBalanceUpdates(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainListOfBalanceUpdatesResponse(rsp)
}

// GetBlockchainListOfBlocksWithResponse request returning *GetBlockchainListOfBlocksResponse
func (c *ClientWithResponses) GetBlockchainListOfBlocksWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfBlocksParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfBlocksResponse, error) {
	rsp, err := c.GetBlockchainListOfBlocks(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainListOfBlocksResponse(rsp)
}

// GetBlockchainFullBlockWithResponse request returning *GetBlockchainFullBlockResponse
func (c *ClientWithResponses) GetBlockchainFullBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, params *GetBlockchainFullBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainFullBlockResponse, error) {
	rsp, err := c.GetBlockchainFullBlock(ctx, asset, blockHash, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainFullBlockResponse(rsp)
}

// GetBlockchainFullTransactionForBlockWithResponse request returning *GetBlockchainFullTransactionForBlockResponse
func (c *ClientWithResponses) GetBlockchainFullTransactionForBlockWithResponse(ctx context.Context, asset BlockchainAsset, blockHash BlockchainBlockHash, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionForBlockParams, reqEditors ...RequestEditorFn) (*GetBlockchainFullTransactionForBlockResponse, error) {
	rsp, err := c.GetBlockchainFullTransactionForBlock(ctx, asset, blockHash, transactionHash, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainFullTransactionForBlockResponse(rsp)
}

// GetTransactionTrackerWithResponse request returning *GetTransactionTrackerResponse
func (c *ClientWithResponses) GetTransactionTrackerWithResponse(ctx context.Context, asset BlockchainAsset, params *GetTransactionTrackerParams, reqEditors ...RequestEditorFn) (*GetTransactionTrackerResponse, error) {
	rsp, err := c.GetTransactionTracker(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionTrackerResponse(rsp)
}

// GetBlockchainListOfTransactionsWithResponse request returning *GetBlockchainListOfTransactionsResponse
func (c *ClientWithResponses) GetBlockchainListOfTransactionsWithResponse(ctx context.Context, asset BlockchainAsset, params *GetBlockchainListOfTransactionsParams, reqEditors ...RequestEditorFn) (*GetBlockchainListOfTransactionsResponse, error) {
	rsp, err := c.GetBlockchainListOfTransactions(ctx, asset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainListOfTransactionsResponse(rsp)
}

// GetBlockchainFullTransactionWithResponse request returning *GetBlockchainFullTransactionResponse
func (c *ClientWithResponses) GetBlockchainFullTransactionWithResponse(ctx context.Context, asset BlockchainAsset, transactionHash BlockchainTransactionHash, params *GetBlockchainFullTransactionParams, reqEditors ...RequestEditorFn) (*GetBlockchainFullTransactionResponse, error) {
	rsp, err := c.GetBlockchainFullTransaction(ctx, asset, transactionHash, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockchainFullTransactionResponse(rsp)
}

// GetCatalogAllAssetAlertRulesWithResponse request returning *GetCatalogAllAssetAlertRulesResponse
func (c *ClientWithResponses) GetCatalogAllAssetAlertRulesWithResponse(ctx context.Context, params *GetCatalogAllAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllAssetAlertRulesResponse, error) {
	rsp, err := c.GetCatalogAllAssetAlertRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllAssetAlertRulesResponse(rsp)
}

// GetCatalogAllAssetsWithResponse request returning *GetCatalogAllAssetsResponse
func (c *ClientWithResponses) GetCatalogAllAssetsWithResponse(ctx context.Context, params *GetCatalogAllAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllAssetsResponse, error) {
	rsp, err := c.GetCatalogAllAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllAssetsResponse(rsp)
}

// GetCatalogAllExchangeAssetsWithResponse request returning *GetCatalogAllExchangeAssetsResponse
func (c *ClientWithResponses) GetCatalogAllExchangeAssetsWithResponse(ctx context.Context, params *GetCatalogAllExchangeAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllExchangeAssetsResponse, error) {
	rsp, err := c.GetCatalogAllExchangeAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllExchangeAssetsResponse(rsp)
}

// GetCatalogAllExchangesWithResponse request returning *GetCatalogAllExchangesResponse
func (c *ClientWithResponses) GetCatalogAllExchangesWithResponse(ctx context.Context, params *GetCatalogAllExchangesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllExchangesResponse, error) {
	rsp, err := c.GetCatalogAllExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllExchangesResponse(rsp)
}

// GetCatalogAllIndexesWithResponse request returning *GetCatalogAllIndexesResponse
func (c *ClientWithResponses) GetCatalogAllIndexesWithResponse(ctx context.Context, params *GetCatalogAllIndexesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllIndexesResponse, error) {
	rsp, err := c.GetCatalogAllIndexes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllIndexesResponse(rsp)
}

// GetCatalogAllInstitutionsWithResponse request returning *GetCatalogAllInstitutionsResponse
func (c *ClientWithResponses) GetCatalogAllInstitutionsWithResponse(ctx context.Context, params *GetCatalogAllInstitutionsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllInstitutionsResponse, error) {
	rsp, err := c.GetCatalogAllInstitutions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllInstitutionsResponse(rsp)
}

// GetCatalogAllMarketCandlesWithResponse request returning *GetCatalogAllMarketCandlesResponse
func (c *ClientWithResponses) GetCatalogAllMarketCandlesWithResponse(ctx context.Context, params *GetCatalogAllMarketCandlesParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMarketCandlesResponse, error) {
	rsp, err := c.GetCatalogAllMarketCandles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllMarketCandlesResponse(rsp)
}

// GetCatalogAllMarketMetricsWithResponse request returning *GetCatalogAllMarketMetricsResponse
func (c *ClientWithResponses) GetCatalogAllMarketMetricsWithResponse(ctx context.Context, params *GetCatalogAllMarketMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMarketMetricsResponse, error) {
	rsp, err := c.GetCatalogAllMarketMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllMarketMetricsResponse(rsp)
}

// GetCatalogAllMarketsWithResponse request returning *GetCatalogAllMarketsResponse
func (c *ClientWithResponses) GetCatalogAllMarketsWithResponse(ctx context.Context, params *GetCatalogAllMarketsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMarketsResponse, error) {
	rsp, err := c.GetCatalogAllMarkets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllMarketsResponse(rsp)
}

// GetCatalogAllMetricsWithResponse request returning *GetCatalogAllMetricsResponse
func (c *ClientWithResponses) GetCatalogAllMetricsWithResponse(ctx context.Context, params *GetCatalogAllMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllMetricsResponse, error) {
	rsp, err := c.GetCatalogAllMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllMetricsResponse(rsp)
}

// GetCatalogAllAssetPairsWithResponse request returning *GetCatalogAllAssetPairsResponse
func (c *ClientWithResponses) GetCatalogAllAssetPairsWithResponse(ctx context.Context, params *GetCatalogAllAssetPairsParams, reqEditors ...RequestEditorFn) (*GetCatalogAllAssetPairsResponse, error) {
	rsp, err := c.GetCatalogAllAssetPairs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAllAssetPairsResponse(rsp)
}

// GetCatalogAssetAlertRulesWithResponse request returning *GetCatalogAssetAlertRulesResponse
func (c *ClientWithResponses) GetCatalogAssetAlertRulesWithResponse(ctx context.Context, params *GetCatalogAssetAlertRulesParams, reqEditors ...RequestEditorFn) (*GetCatalogAssetAlertRulesResponse, error) {
	rsp, err := c.GetCatalogAssetAlertRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAssetAlertRulesResponse(rsp)
}

// GetCatalogAssetsWithResponse request returning *GetCatalogAssetsResponse
func (c *ClientWithResponses) GetCatalogAssetsWithResponse(ctx context.Context, params *GetCatalogAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogAssetsResponse, error) {
	rsp, err := c.GetCatalogAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAssetsResponse(rsp)
}

// GetCatalogExchangeAssetsWithResponse request returning *GetCatalogExchangeAssetsResponse
func (c *ClientWithResponses) GetCatalogExchangeAssetsWithResponse(ctx context.Context, params *GetCatalogExchangeAssetsParams, reqEditors ...RequestEditorFn) (*GetCatalogExchangeAssetsResponse, error) {
	rsp, err := c.GetCatalogExchangeAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogExchangeAssetsResponse(rsp)
}

// GetCatalogExchangesWithResponse request returning *GetCatalogExchangesResponse
func (c *ClientWithResponses) GetCatalogExchangesWithResponse(ctx context.Context, params *GetCatalogExchangesParams, reqEditors ...RequestEditorFn) (*GetCatalogExchangesResponse, error) {
	rsp, err := c.GetCatalogExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogExchangesResponse(rsp)
}

// GetCatalogIndexesWithResponse request returning *GetCatalogIndexesResponse
func (c *ClientWithResponses) GetCatalogIndexesWithResponse(ctx context.Context, params *GetCatalogIndexesParams, reqEditors ...RequestEditorFn) (*GetCatalogIndexesResponse, error) {
	rsp, err := c.GetCatalogIndexes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogIndexesResponse(rsp)
}

// GetCatalogInstitutionsWithResponse request returning *GetCatalogInstitutionsResponse
func (c *ClientWithResponses) GetCatalogInstitutionsWithResponse(ctx context.Context, params *GetCatalogInstitutionsParams, reqEditors ...RequestEditorFn) (*GetCatalogInstitutionsResponse, error) {
	rsp, err := c.GetCatalogInstitutions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogInstitutionsResponse(rsp)
}

// GetCatalogMarketCandlesWithResponse request returning *GetCatalogMarketCandlesResponse
func (c *ClientWithResponses) GetCatalogMarketCandlesWithResponse(ctx context.Context, params *GetCatalogMarketCandlesParams, reqEditors ...RequestEditorFn) (*GetCatalogMarketCandlesResponse, error) {
	rsp, err := c.GetCatalogMarketCandles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogMarketCandlesResponse(rsp)
}

// GetCatalogMarketMetricsWithResponse request returning *GetCatalogMarketMetricsResponse
func (c *ClientWithResponses) GetCatalogMarketMetricsWithResponse(ctx context.Context, params *GetCatalogMarketMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogMarketMetricsResponse, error) {
	rsp, err := c.GetCatalogMarketMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogMarketMetricsResponse(rsp)
}

// GetCatalogMarketsWithResponse request returning *GetCatalogMarketsResponse
func (c *ClientWithResponses) GetCatalogMarketsWithResponse(ctx context.Context, params *GetCatalogMarketsParams, reqEditors ...RequestEditorFn) (*GetCatalogMarketsResponse, error) {
	rsp, err := c.GetCatalogMarkets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogMarketsResponse(rsp)
}

// GetCatalogMetricsWithResponse request returning *GetCatalogMetricsResponse
func (c *ClientWithResponses) GetCatalogMetricsWithResponse(ctx context.Context, params *GetCatalogMetricsParams, reqEditors ...RequestEditorFn) (*GetCatalogMetricsResponse, error) {
	rsp, err := c.GetCatalogMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogMetricsResponse(rsp)
}

// GetCatalogAssetPairsWithResponse request returning *GetCatalogAssetPairsResponse
func (c *ClientWithResponses) GetCatalogAssetPairsWithResponse(ctx context.Context, params *GetCatalogAssetPairsParams, reqEditors ...RequestEditorFn) (*GetCatalogAssetPairsResponse, error) {
	rsp, err := c.GetCatalogAssetPairs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogAssetPairsResponse(rsp)
}

// GetTimeseriesStreamAssetMetricsWithResponse request returning *GetTimeseriesStreamAssetMetricsResponse
func (c *ClientWithResponses) GetTimeseriesStreamAssetMetricsWithResponse(ctx context.Context, params *GetTimeseriesStreamAssetMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamAssetMetricsResponse, error) {
	rsp, err := c.GetTimeseriesStreamAssetMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesStreamAssetMetricsResponse(rsp)
}

// GetTimeseriesStreamMarketOrderbooksWithResponse request returning *GetTimeseriesStreamMarketOrderbooksResponse
func (c *ClientWithResponses) GetTimeseriesStreamMarketOrderbooksWithResponse(ctx context.Context, params *GetTimeseriesStreamMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamMarketOrderbooksResponse, error) {
	rsp, err := c.GetTimeseriesStreamMarketOrderbooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesStreamMarketOrderbooksResponse(rsp)
}

// GetTimeseriesStreamMarketQuotesWithResponse request returning *GetTimeseriesStreamMarketQuotesResponse
func (c *ClientWithResponses) GetTimeseriesStreamMarketQuotesWithResponse(ctx context.Context, params *GetTimeseriesStreamMarketQuotesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamMarketQuotesResponse, error) {
	rsp, err := c.GetTimeseriesStreamMarketQuotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesStreamMarketQuotesResponse(rsp)
}

// GetTimeseriesStreamMarketTradesWithResponse request returning *GetTimeseriesStreamMarketTradesResponse
func (c *ClientWithResponses) GetTimeseriesStreamMarketTradesWithResponse(ctx context.Context, params *GetTimeseriesStreamMarketTradesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesStreamMarketTradesResponse, error) {
	rsp, err := c.GetTimeseriesStreamMarketTrades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesStreamMarketTradesResponse(rsp)
}

// GetAssetAlertsWithResponse request returning *GetAssetAlertsResponse
func (c *ClientWithResponses) GetAssetAlertsWithResponse(ctx context.Context, params *GetAssetAlertsParams, reqEditors ...RequestEditorFn) (*GetAssetAlertsResponse, error) {
	rsp, err := c.GetAssetAlerts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetAlertsResponse(rsp)
}

// GetAssetChainsWithResponse request returning *GetAssetChainsResponse
func (c *ClientWithResponses) GetAssetChainsWithResponse(ctx context.Context, params *GetAssetChainsParams, reqEditors ...RequestEditorFn) (*GetAssetChainsResponse, error) {
	rsp, err := c.GetAssetChains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetChainsResponse(rsp)
}

// GetTimeseriesAssetMetricsWithResponse request returning *GetTimeseriesAssetMetricsResponse
func (c *ClientWithResponses) GetTimeseriesAssetMetricsWithResponse(ctx context.Context, params *GetTimeseriesAssetMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesAssetMetricsResponse, error) {
	rsp, err := c.GetTimeseriesAssetMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesAssetMetricsResponse(rsp)
}

// GetTimeseriesExchangeAssetMetricsWithResponse request returning *GetTimeseriesExchangeAssetMetricsResponse
func (c *ClientWithResponses) GetTimeseriesExchangeAssetMetricsWithResponse(ctx context.Context, params *GetTimeseriesExchangeAssetMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesExchangeAssetMetricsResponse, error) {
	rsp, err := c.GetTimeseriesExchangeAssetMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesExchangeAssetMetricsResponse(rsp)
}

// GetTimeseriesExchangeMetricsWithResponse request returning *GetTimeseriesExchangeMetricsResponse
func (c *ClientWithResponses) GetTimeseriesExchangeMetricsWithResponse(ctx context.Context, params *GetTimeseriesExchangeMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesExchangeMetricsResponse, error) {
	rsp, err := c.GetTimeseriesExchangeMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesExchangeMetricsResponse(rsp)
}

// GetTimeseriesIndexConstituentsWithResponse request returning *GetTimeseriesIndexConstituentsResponse
func (c *ClientWithResponses) GetTimeseriesIndexConstituentsWithResponse(ctx context.Context, params *GetTimeseriesIndexConstituentsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesIndexConstituentsResponse, error) {
	rsp, err := c.GetTimeseriesIndexConstituents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesIndexConstituentsResponse(rsp)
}

// GetTimeseriesIndexLevelsWithResponse request returning *GetTimeseriesIndexLevelsResponse
func (c *ClientWithResponses) GetTimeseriesIndexLevelsWithResponse(ctx context.Context, params *GetTimeseriesIndexLevelsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesIndexLevelsResponse, error) {
	rsp, err := c.GetTimeseriesIndexLevels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesIndexLevelsResponse(rsp)
}

// GetTimeseriesInstitutionMetricsWithResponse request returning *GetTimeseriesInstitutionMetricsResponse
func (c *ClientWithResponses) GetTimeseriesInstitutionMetricsWithResponse(ctx context.Context, params *GetTimeseriesInstitutionMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesInstitutionMetricsResponse, error) {
	rsp, err := c.GetTimeseriesInstitutionMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesInstitutionMetricsResponse(rsp)
}

// GetTimeseriesMarketCandlesWithResponse request returning *GetTimeseriesMarketCandlesResponse
func (c *ClientWithResponses) GetTimeseriesMarketCandlesWithResponse(ctx context.Context, params *GetTimeseriesMarketCandlesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketCandlesResponse, error) {
	rsp, err := c.GetTimeseriesMarketCandles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketCandlesResponse(rsp)
}

// GetTimeseriesMarketContractPricesWithResponse request returning *GetTimeseriesMarketContractPricesResponse
func (c *ClientWithResponses) GetTimeseriesMarketContractPricesWithResponse(ctx context.Context, params *GetTimeseriesMarketContractPricesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketContractPricesResponse, error) {
	rsp, err := c.GetTimeseriesMarketContractPrices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketContractPricesResponse(rsp)
}

// GetTimeseriesMarketFundingRatesWithResponse request returning *GetTimeseriesMarketFundingRatesResponse
func (c *ClientWithResponses) GetTimeseriesMarketFundingRatesWithResponse(ctx context.Context, params *GetTimeseriesMarketFundingRatesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketFundingRatesResponse, error) {
	rsp, err := c.GetTimeseriesMarketFundingRates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketFundingRatesResponse(rsp)
}

// GetTimeseriesMarketGreeksWithResponse request returning *GetTimeseriesMarketGreeksResponse
func (c *ClientWithResponses) GetTimeseriesMarketGreeksWithResponse(ctx context.Context, params *GetTimeseriesMarketGreeksParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketGreeksResponse, error) {
	rsp, err := c.GetTimeseriesMarketGreeks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketGreeksResponse(rsp)
}

// GetTimeseriesMarketImpliedVolatilityWithResponse request returning *GetTimeseriesMarketImpliedVolatilityResponse
func (c *ClientWithResponses) GetTimeseriesMarketImpliedVolatilityWithResponse(ctx context.Context, params *GetTimeseriesMarketImpliedVolatilityParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketImpliedVolatilityResponse, error) {
	rsp, err := c.GetTimeseriesMarketImpliedVolatility(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketImpliedVolatilityResponse(rsp)
}

// GetTimeseriesMarketLiquidationsWithResponse request returning *GetTimeseriesMarketLiquidationsResponse
func (c *ClientWithResponses) GetTimeseriesMarketLiquidationsWithResponse(ctx context.Context, params *GetTimeseriesMarketLiquidationsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketLiquidationsResponse, error) {
	rsp, err := c.GetTimeseriesMarketLiquidations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketLiquidationsResponse(rsp)
}

// GetTimeseriesMarketMetricsWithResponse request returning *GetTimeseriesMarketMetricsResponse
func (c *ClientWithResponses) GetTimeseriesMarketMetricsWithResponse(ctx context.Context, params *GetTimeseriesMarketMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketMetricsResponse, error) {
	rsp, err := c.GetTimeseriesMarketMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketMetricsResponse(rsp)
}

// GetTimeseriesMarketOpenInteresetWithResponse request returning *GetTimeseriesMarketOpenInteresetResponse
func (c *ClientWithResponses) GetTimeseriesMarketOpenInteresetWithResponse(ctx context.Context, params *GetTimeseriesMarketOpenInteresetParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketOpenInteresetResponse, error) {
	rsp, err := c.GetTimeseriesMarketOpenIntereset(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketOpenInteresetResponse(rsp)
}

// GetTimeseriesMarketOrderbooksWithResponse request returning *GetTimeseriesMarketOrderbooksResponse
func (c *ClientWithResponses) GetTimeseriesMarketOrderbooksWithResponse(ctx context.Context, params *GetTimeseriesMarketOrderbooksParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketOrderbooksResponse, error) {
	rsp, err := c.GetTimeseriesMarketOrderbooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketOrderbooksResponse(rsp)
}

// GetTimeseriesMarketQuotesWithResponse request returning *GetTimeseriesMarketQuotesResponse
func (c *ClientWithResponses) GetTimeseriesMarketQuotesWithResponse(ctx context.Context, params *GetTimeseriesMarketQuotesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketQuotesResponse, error) {
	rsp, err := c.GetTimeseriesMarketQuotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketQuotesResponse(rsp)
}

// GetTimeseriesMarketTradesWithResponse request returning *GetTimeseriesMarketTradesResponse
func (c *ClientWithResponses) GetTimeseriesMarketTradesWithResponse(ctx context.Context, params *GetTimeseriesMarketTradesParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMarketTradesResponse, error) {
	rsp, err := c.GetTimeseriesMarketTrades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMarketTradesResponse(rsp)
}

// GetMempoolFeeratesWithResponse request returning *GetMempoolFeeratesResponse
func (c *ClientWithResponses) GetMempoolFeeratesWithResponse(ctx context.Context, params *GetMempoolFeeratesParams, reqEditors ...RequestEditorFn) (*GetMempoolFeeratesResponse, error) {
	rsp, err := c.GetMempoolFeerates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMempoolFeeratesResponse(rsp)
}

// GetTimeseriesMiningPoolTipsSummaryWithResponse request returning *GetTimeseriesMiningPoolTipsSummaryResponse
func (c *ClientWithResponses) GetTimeseriesMiningPoolTipsSummaryWithResponse(ctx context.Context, params *GetTimeseriesMiningPoolTipsSummaryParams, reqEditors ...RequestEditorFn) (*GetTimeseriesMiningPoolTipsSummaryResponse, error) {
	rsp, err := c.GetTimeseriesMiningPoolTipsSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesMiningPoolTipsSummaryResponse(rsp)
}

// GetTimeseriesPairMetricsWithResponse request returning *GetTimeseriesPairMetricsResponse
func (c *ClientWithResponses) GetTimeseriesPairMetricsWithResponse(ctx context.Context, params *GetTimeseriesPairMetricsParams, reqEditors ...RequestEditorFn) (*GetTimeseriesPairMetricsResponse, error) {
	rsp, err := c.GetTimeseriesPairMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeseriesPairMetricsResponse(rsp)
}

// ParseGetBlockchainV2ListOfAccountsResponse parses an HTTP response from a GetBlockchainV2ListOfAccountsWithResponse call
func ParseGetBlockchainV2ListOfAccountsResponse(rsp *http.Response) (*GetBlockchainV2ListOfAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2ListOfAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainAccountsResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainV2ListOfBalanceUpdatesResponse parses an HTTP response from a GetBlockchainV2ListOfBalanceUpdatesWithResponse call
func ParseGetBlockchainV2ListOfBalanceUpdatesResponse(rsp *http.Response) (*GetBlockchainV2ListOfBalanceUpdatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2ListOfBalanceUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainBalanceUpdatesResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainV2ListOfBlocksResponse parses an HTTP response from a GetBlockchainV2ListOfBlocksWithResponse call
func ParseGetBlockchainV2ListOfBlocksResponse(rsp *http.Response) (*GetBlockchainV2ListOfBlocksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2ListOfBlocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainBlocksResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainV2FullBlockResponse parses an HTTP response from a GetBlockchainV2FullBlockWithResponse call
func ParseGetBlockchainV2FullBlockResponse(rsp *http.Response) (*GetBlockchainV2FullBlockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2FullBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainFullBlockResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainV2FullTransactionForBlockResponse parses an HTTP response from a GetBlockchainV2FullTransactionForBlockWithResponse call
func ParseGetBlockchainV2FullTransactionForBlockResponse(rsp *http.Response) (*GetBlockchainV2FullTransactionForBlockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2FullTransactionForBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainFullSingleTransactionResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainV2ListOfSubAccountsResponse parses an HTTP response from a GetBlockchainV2ListOfSubAccountsWithResponse call
func ParseGetBlockchainV2ListOfSubAccountsResponse(rsp *http.Response) (*GetBlockchainV2ListOfSubAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2ListOfSubAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainSubAccountsResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainV2ListOfTransactionsResponse parses an HTTP response from a GetBlockchainV2ListOfTransactionsWithResponse call
func ParseGetBlockchainV2ListOfTransactionsResponse(rsp *http.Response) (*GetBlockchainV2ListOfTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2ListOfTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainTransactionsResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainV2FullTransactionResponse parses an HTTP response from a GetBlockchainV2FullTransactionWithResponse call
func ParseGetBlockchainV2FullTransactionResponse(rsp *http.Response) (*GetBlockchainV2FullTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainV2FullTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainFullSingleTransactionResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainListOfAccountsResponse parses an HTTP response from a GetBlockchainListOfAccountsWithResponse call
func ParseGetBlockchainListOfAccountsResponse(rsp *http.Response) (*GetBlockchainListOfAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainListOfAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainAccountsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainListOfBalanceUpdatesResponse parses an HTTP response from a GetBlockchainListOfBalanceUpdatesWithResponse call
func ParseGetBlockchainListOfBalanceUpdatesResponse(rsp *http.Response) (*GetBlockchainListOfBalanceUpdatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainListOfBalanceUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainBalanceUpdatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainListOfBlocksResponse parses an HTTP response from a GetBlockchainListOfBlocksWithResponse call
func ParseGetBlockchainListOfBlocksResponse(rsp *http.Response) (*GetBlockchainListOfBlocksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainListOfBlocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainBlocksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainFullBlockResponse parses an HTTP response from a GetBlockchainFullBlockWithResponse call
func ParseGetBlockchainFullBlockResponse(rsp *http.Response) (*GetBlockchainFullBlockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainFullBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainFullBlockResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainFullTransactionForBlockResponse parses an HTTP response from a GetBlockchainFullTransactionForBlockWithResponse call
func ParseGetBlockchainFullTransactionForBlockResponse(rsp *http.Response) (*GetBlockchainFullTransactionForBlockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainFullTransactionForBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainFullSingleTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTransactionTrackerResponse parses an HTTP response from a GetTransactionTrackerWithResponse call
func ParseGetTransactionTrackerResponse(rsp *http.Response) (*GetTransactionTrackerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionTrackerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TxTrackerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainListOfTransactionsResponse parses an HTTP response from a GetBlockchainListOfTransactionsWithResponse call
func ParseGetBlockchainListOfTransactionsResponse(rsp *http.Response) (*GetBlockchainListOfTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainListOfTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBlockchainFullTransactionResponse parses an HTTP response from a GetBlockchainFullTransactionWithResponse call
func ParseGetBlockchainFullTransactionResponse(rsp *http.Response) (*GetBlockchainFullTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockchainFullTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockchainFullSingleTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllAssetAlertRulesResponse parses an HTTP response from a GetCatalogAllAssetAlertRulesWithResponse call
func ParseGetCatalogAllAssetAlertRulesResponse(rsp *http.Response) (*GetCatalogAllAssetAlertRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllAssetAlertRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetAlertRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllAssetsResponse parses an HTTP response from a GetCatalogAllAssetsWithResponse call
func ParseGetCatalogAllAssetsResponse(rsp *http.Response) (*GetCatalogAllAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllExchangeAssetsResponse parses an HTTP response from a GetCatalogAllExchangeAssetsWithResponse call
func ParseGetCatalogAllExchangeAssetsResponse(rsp *http.Response) (*GetCatalogAllExchangeAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllExchangeAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeAssetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllExchangesResponse parses an HTTP response from a GetCatalogAllExchangesWithResponse call
func ParseGetCatalogAllExchangesResponse(rsp *http.Response) (*GetCatalogAllExchangesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllIndexesResponse parses an HTTP response from a GetCatalogAllIndexesWithResponse call
func ParseGetCatalogAllIndexesResponse(rsp *http.Response) (*GetCatalogAllIndexesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllInstitutionsResponse parses an HTTP response from a GetCatalogAllInstitutionsWithResponse call
func ParseGetCatalogAllInstitutionsResponse(rsp *http.Response) (*GetCatalogAllInstitutionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllInstitutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstitutionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllMarketCandlesResponse parses an HTTP response from a GetCatalogAllMarketCandlesWithResponse call
func ParseGetCatalogAllMarketCandlesResponse(rsp *http.Response) (*GetCatalogAllMarketCandlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllMarketCandlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogMarketCandlesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllMarketMetricsResponse parses an HTTP response from a GetCatalogAllMarketMetricsWithResponse call
func ParseGetCatalogAllMarketMetricsResponse(rsp *http.Response) (*GetCatalogAllMarketMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllMarketMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogMarketMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllMarketsResponse parses an HTTP response from a GetCatalogAllMarketsWithResponse call
func ParseGetCatalogAllMarketsResponse(rsp *http.Response) (*GetCatalogAllMarketsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllMarketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllMetricsResponse parses an HTTP response from a GetCatalogAllMetricsWithResponse call
func ParseGetCatalogAllMetricsResponse(rsp *http.Response) (*GetCatalogAllMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAllAssetPairsResponse parses an HTTP response from a GetCatalogAllAssetPairsWithResponse call
func ParseGetCatalogAllAssetPairsResponse(rsp *http.Response) (*GetCatalogAllAssetPairsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAllAssetPairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PairsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAssetAlertRulesResponse parses an HTTP response from a GetCatalogAssetAlertRulesWithResponse call
func ParseGetCatalogAssetAlertRulesResponse(rsp *http.Response) (*GetCatalogAssetAlertRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAssetAlertRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetAlertRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCatalogAssetsResponse parses an HTTP response from a GetCatalogAssetsWithResponse call
func ParseGetCatalogAssetsResponse(rsp *http.Response) (*GetCatalogAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogExchangeAssetsResponse parses an HTTP response from a GetCatalogExchangeAssetsWithResponse call
func ParseGetCatalogExchangeAssetsResponse(rsp *http.Response) (*GetCatalogExchangeAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogExchangeAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeAssetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogExchangesResponse parses an HTTP response from a GetCatalogExchangesWithResponse call
func ParseGetCatalogExchangesResponse(rsp *http.Response) (*GetCatalogExchangesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogIndexesResponse parses an HTTP response from a GetCatalogIndexesWithResponse call
func ParseGetCatalogIndexesResponse(rsp *http.Response) (*GetCatalogIndexesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogInstitutionsResponse parses an HTTP response from a GetCatalogInstitutionsWithResponse call
func ParseGetCatalogInstitutionsResponse(rsp *http.Response) (*GetCatalogInstitutionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogInstitutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstitutionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogMarketCandlesResponse parses an HTTP response from a GetCatalogMarketCandlesWithResponse call
func ParseGetCatalogMarketCandlesResponse(rsp *http.Response) (*GetCatalogMarketCandlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogMarketCandlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogMarketCandlesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogMarketMetricsResponse parses an HTTP response from a GetCatalogMarketMetricsWithResponse call
func ParseGetCatalogMarketMetricsResponse(rsp *http.Response) (*GetCatalogMarketMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogMarketMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogMarketMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogMarketsResponse parses an HTTP response from a GetCatalogMarketsWithResponse call
func ParseGetCatalogMarketsResponse(rsp *http.Response) (*GetCatalogMarketsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogMarketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogMetricsResponse parses an HTTP response from a GetCatalogMetricsWithResponse call
func ParseGetCatalogMetricsResponse(rsp *http.Response) (*GetCatalogMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogAssetPairsResponse parses an HTTP response from a GetCatalogAssetPairsWithResponse call
func ParseGetCatalogAssetPairsResponse(rsp *http.Response) (*GetCatalogAssetPairsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogAssetPairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PairsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesStreamAssetMetricsResponse parses an HTTP response from a GetTimeseriesStreamAssetMetricsWithResponse call
func ParseGetTimeseriesStreamAssetMetricsResponse(rsp *http.Response) (*GetTimeseriesStreamAssetMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesStreamAssetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest StreamingAssetMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTimeseriesStreamMarketOrderbooksResponse parses an HTTP response from a GetTimeseriesStreamMarketOrderbooksWithResponse call
func ParseGetTimeseriesStreamMarketOrderbooksResponse(rsp *http.Response) (*GetTimeseriesStreamMarketOrderbooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesStreamMarketOrderbooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest StreamingMarketOrderbook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTimeseriesStreamMarketQuotesResponse parses an HTTP response from a GetTimeseriesStreamMarketQuotesWithResponse call
func ParseGetTimeseriesStreamMarketQuotesResponse(rsp *http.Response) (*GetTimeseriesStreamMarketQuotesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesStreamMarketQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest StreamingMarketQuote
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTimeseriesStreamMarketTradesResponse parses an HTTP response from a GetTimeseriesStreamMarketTradesWithResponse call
func ParseGetTimeseriesStreamMarketTradesResponse(rsp *http.Response) (*GetTimeseriesStreamMarketTradesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesStreamMarketTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest StreamingMarketTrade
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAssetAlertsResponse parses an HTTP response from a GetAssetAlertsWithResponse call
func ParseGetAssetAlertsResponse(rsp *http.Response) (*GetAssetAlertsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetAlertsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAssetChainsResponse parses an HTTP response from a GetAssetChainsWithResponse call
func ParseGetAssetChainsResponse(rsp *http.Response) (*GetAssetChainsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetChainsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesAssetMetricsResponse parses an HTTP response from a GetTimeseriesAssetMetricsWithResponse call
func ParseGetTimeseriesAssetMetricsResponse(rsp *http.Response) (*GetTimeseriesAssetMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesAssetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetTimeseriesExchangeAssetMetricsResponse parses an HTTP response from a GetTimeseriesExchangeAssetMetricsWithResponse call
func ParseGetTimeseriesExchangeAssetMetricsResponse(rsp *http.Response) (*GetTimeseriesExchangeAssetMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesExchangeAssetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeAssetMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesExchangeMetricsResponse parses an HTTP response from a GetTimeseriesExchangeMetricsWithResponse call
func ParseGetTimeseriesExchangeMetricsResponse(rsp *http.Response) (*GetTimeseriesExchangeMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesExchangeMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesIndexConstituentsResponse parses an HTTP response from a GetTimeseriesIndexConstituentsWithResponse call
func ParseGetTimeseriesIndexConstituentsResponse(rsp *http.Response) (*GetTimeseriesIndexConstituentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesIndexConstituentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexConstituentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesIndexLevelsResponse parses an HTTP response from a GetTimeseriesIndexLevelsWithResponse call
func ParseGetTimeseriesIndexLevelsResponse(rsp *http.Response) (*GetTimeseriesIndexLevelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesIndexLevelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexLevelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesInstitutionMetricsResponse parses an HTTP response from a GetTimeseriesInstitutionMetricsWithResponse call
func ParseGetTimeseriesInstitutionMetricsResponse(rsp *http.Response) (*GetTimeseriesInstitutionMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesInstitutionMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstitutionMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketCandlesResponse parses an HTTP response from a GetTimeseriesMarketCandlesWithResponse call
func ParseGetTimeseriesMarketCandlesResponse(rsp *http.Response) (*GetTimeseriesMarketCandlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketCandlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketCandlesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketContractPricesResponse parses an HTTP response from a GetTimeseriesMarketContractPricesWithResponse call
func ParseGetTimeseriesMarketContractPricesResponse(rsp *http.Response) (*GetTimeseriesMarketContractPricesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketContractPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketContractPricesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketFundingRatesResponse parses an HTTP response from a GetTimeseriesMarketFundingRatesWithResponse call
func ParseGetTimeseriesMarketFundingRatesResponse(rsp *http.Response) (*GetTimeseriesMarketFundingRatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketFundingRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketFundingRatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketGreeksResponse parses an HTTP response from a GetTimeseriesMarketGreeksWithResponse call
func ParseGetTimeseriesMarketGreeksResponse(rsp *http.Response) (*GetTimeseriesMarketGreeksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketGreeksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketGreeksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketImpliedVolatilityResponse parses an HTTP response from a GetTimeseriesMarketImpliedVolatilityWithResponse call
func ParseGetTimeseriesMarketImpliedVolatilityResponse(rsp *http.Response) (*GetTimeseriesMarketImpliedVolatilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketImpliedVolatilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketImpliedVolatilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketLiquidationsResponse parses an HTTP response from a GetTimeseriesMarketLiquidationsWithResponse call
func ParseGetTimeseriesMarketLiquidationsResponse(rsp *http.Response) (*GetTimeseriesMarketLiquidationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketLiquidationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketLiquidationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketMetricsResponse parses an HTTP response from a GetTimeseriesMarketMetricsWithResponse call
func ParseGetTimeseriesMarketMetricsResponse(rsp *http.Response) (*GetTimeseriesMarketMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketOpenInteresetResponse parses an HTTP response from a GetTimeseriesMarketOpenInteresetWithResponse call
func ParseGetTimeseriesMarketOpenInteresetResponse(rsp *http.Response) (*GetTimeseriesMarketOpenInteresetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketOpenInteresetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketOpenInterestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketOrderbooksResponse parses an HTTP response from a GetTimeseriesMarketOrderbooksWithResponse call
func ParseGetTimeseriesMarketOrderbooksResponse(rsp *http.Response) (*GetTimeseriesMarketOrderbooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketOrderbooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketOrderbookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketQuotesResponse parses an HTTP response from a GetTimeseriesMarketQuotesWithResponse call
func ParseGetTimeseriesMarketQuotesResponse(rsp *http.Response) (*GetTimeseriesMarketQuotesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketQuotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMarketTradesResponse parses an HTTP response from a GetTimeseriesMarketTradesWithResponse call
func ParseGetTimeseriesMarketTradesResponse(rsp *http.Response) (*GetTimeseriesMarketTradesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMarketTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketTradesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetMempoolFeeratesResponse parses an HTTP response from a GetMempoolFeeratesWithResponse call
func ParseGetMempoolFeeratesResponse(rsp *http.Response) (*GetMempoolFeeratesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMempoolFeeratesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MempoolFeeratesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesMiningPoolTipsSummaryResponse parses an HTTP response from a GetTimeseriesMiningPoolTipsSummaryWithResponse call
func ParseGetTimeseriesMiningPoolTipsSummaryResponse(rsp *http.Response) (*GetTimeseriesMiningPoolTipsSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesMiningPoolTipsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MiningPoolTipsSummaryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTimeseriesPairMetricsResponse parses an HTTP response from a GetTimeseriesPairMetricsWithResponse call
func ParseGetTimeseriesPairMetricsResponse(rsp *http.Response) (*GetTimeseriesPairMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeseriesPairMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PairMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

